<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Module: Numo::GSL::Sf
  
    &mdash; Documentation by YARD 0.9.12
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "Numo::GSL::Sf";
  relpath = '../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../x_index.html">Index (S)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../Numo.html" title="Numo (module)">Numo</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../GSL.html" title="Numo::GSL (module)">GSL</a></span></span>
     &raquo; 
    <span class="title">Sf</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Module: Numo::GSL::Sf
  
  
  
</h1>
<div class="box_info">
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>ext/numo/gsl/sf/gsl_sf.c</dd>
  </dl>
  
</div>

<h2>Defined Under Namespace</h2>
<p class="children">
  
    
  
    
      <strong class="classes">Classes:</strong> <span class='object_link'><a href="Sf/Mathieu.html" title="Numo::GSL::Sf::Mathieu (class)">Mathieu</a></span>
    
  
</p>







  
    <h2>
      Class Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai-class_method" title="airy_Ai (class method)">.<strong>airy_Ai</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Ai(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv-class_method" title="airy_Ai_deriv (class method)">.<strong>airy_Ai_deriv</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Ai’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv_e-class_method" title="airy_Ai_deriv_e (class method)">.<strong>airy_Ai_deriv_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Ai’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv_scaled-class_method" title="airy_Ai_deriv_scaled (class method)">.<strong>airy_Ai_deriv_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_A(x) Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv_scaled_e-class_method" title="airy_Ai_deriv_scaled_e (class method)">.<strong>airy_Ai_deriv_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_A(x) Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_e-class_method" title="airy_Ai_e (class method)">.<strong>airy_Ai_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Ai(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_scaled-class_method" title="airy_Ai_scaled (class method)">.<strong>airy_Ai_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_A(x) Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_scaled_e-class_method" title="airy_Ai_scaled_e (class method)">.<strong>airy_Ai_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_A(x) Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi-class_method" title="airy_Bi (class method)">.<strong>airy_Bi</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Bi(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv-class_method" title="airy_Bi_deriv (class method)">.<strong>airy_Bi_deriv</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Bi’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv_e-class_method" title="airy_Bi_deriv_e (class method)">.<strong>airy_Bi_deriv_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Bi’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv_scaled-class_method" title="airy_Bi_deriv_scaled (class method)">.<strong>airy_Bi_deriv_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_B(x) Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv_scaled_e-class_method" title="airy_Bi_deriv_scaled_e (class method)">.<strong>airy_Bi_deriv_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_B(x) Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_e-class_method" title="airy_Bi_e (class method)">.<strong>airy_Bi_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Bi(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_scaled-class_method" title="airy_Bi_scaled (class method)">.<strong>airy_Bi_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_B(x) Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_scaled_e-class_method" title="airy_Bi_scaled_e (class method)">.<strong>airy_Bi_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_B(x) Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai-class_method" title="airy_zero_Ai (class method)">.<strong>airy_zero_Ai</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai_deriv-class_method" title="airy_zero_Ai_deriv (class method)">.<strong>airy_zero_Ai_deriv</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai_deriv_e-class_method" title="airy_zero_Ai_deriv_e (class method)">.<strong>airy_zero_Ai_deriv_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai_e-class_method" title="airy_zero_Ai_e (class method)">.<strong>airy_zero_Ai_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi-class_method" title="airy_zero_Bi (class method)">.<strong>airy_zero_Bi</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi_deriv-class_method" title="airy_zero_Bi_deriv (class method)">.<strong>airy_zero_Bi_deriv</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi_deriv_e-class_method" title="airy_zero_Bi_deriv_e (class method)">.<strong>airy_zero_Bi_deriv_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi_e-class_method" title="airy_zero_Bi_e (class method)">.<strong>airy_zero_Bi_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#angle_restrict_pos-class_method" title="angle_restrict_pos (class method)">.<strong>angle_restrict_pos</strong>(theta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines force the angle theta to lie in the range [0, 2\pi).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#angle_restrict_symm-class_method" title="angle_restrict_symm (class method)">.<strong>angle_restrict_symm</strong>(theta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines force the angle theta to lie in the range (-\pi,\pi].</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#atanint-class_method" title="atanint (class method)">.<strong>atanint</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$ AtanInt(x) = \int_0^x dt \arctan(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#atanint_e-class_method" title="atanint_e (class method)">.<strong>atanint_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$ AtanInt(x) = \int_0^x dt \arctan(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0-class_method" title="bessel_I0 (class method)">.<strong>bessel_I0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of zeroth order, I_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0_e-class_method" title="bessel_I0_e (class method)">.<strong>bessel_I0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of zeroth order, I_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0_scaled-class_method" title="bessel_I0_scaled (class method)">.<strong>bessel_I0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of zeroth order \exp(-</td>
      <td>x</td>
      <td>) I_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i0_scaled-class_method" title="bessel_i0_scaled (class method)">.<strong>bessel_i0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of zeroth order, \exp(-</td>
      <td>x</td>
      <td>) i_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0_scaled_e-class_method" title="bessel_I0_scaled_e (class method)">.<strong>bessel_I0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of zeroth order \exp(-</td>
      <td>x</td>
      <td>) I_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i0_scaled_e-class_method" title="bessel_i0_scaled_e (class method)">.<strong>bessel_i0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of zeroth order, \exp(-</td>
      <td>x</td>
      <td>) i_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1-class_method" title="bessel_I1 (class method)">.<strong>bessel_I1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of first order, I_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1_e-class_method" title="bessel_I1_e (class method)">.<strong>bessel_I1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of first order, I_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1_scaled-class_method" title="bessel_I1_scaled (class method)">.<strong>bessel_I1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of first order \exp(-</td>
      <td>x</td>
      <td>) I_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i1_scaled-class_method" title="bessel_i1_scaled (class method)">.<strong>bessel_i1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of first order, \exp(-</td>
      <td>x</td>
      <td>) i_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1_scaled_e-class_method" title="bessel_I1_scaled_e (class method)">.<strong>bessel_I1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of first order \exp(-</td>
      <td>x</td>
      <td>) I_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i1_scaled_e-class_method" title="bessel_i1_scaled_e (class method)">.<strong>bessel_i1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of first order, \exp(-</td>
      <td>x</td>
      <td>) i_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i2_scaled-class_method" title="bessel_i2_scaled (class method)">.<strong>bessel_i2_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of second order,  \exp(-</td>
      <td>x</td>
      <td>) i_2(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i2_scaled_e-class_method" title="bessel_i2_scaled_e (class method)">.<strong>bessel_i2_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of second order,  \exp(-</td>
      <td>x</td>
      <td>) i_2(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_il_scaled-class_method" title="bessel_il_scaled (class method)">.<strong>bessel_il_scaled</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of order l,  \exp(-</td>
      <td>x</td>
      <td>) i_l(x) Domain: l &gt;= 0 Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_il_scaled_array-class_method" title="bessel_il_scaled_array (class method)">.<strong>bessel_il_scaled_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>This routine computes the values of the scaled regular modified spherical Bessel functions \exp(-</td>
      <td>x</td>
      <td>) i_l(x) for l from 0 to lmax inclusive for $lmax \geq 0$ lmax &gt;= 0, storing the results in the array result_array.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_il_scaled_e-class_method" title="bessel_il_scaled_e (class method)">.<strong>bessel_il_scaled_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of order l,  \exp(-</td>
      <td>x</td>
      <td>) i_l(x) Domain: l &gt;= 0 Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In-class_method" title="bessel_In (class method)">.<strong>bessel_In</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of order n, I_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_array-class_method" title="bessel_In_array (class method)">.<strong>bessel_In_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the regular modified cylindrical Bessel functions I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_e-class_method" title="bessel_In_e (class method)">.<strong>bessel_In_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of order n, I_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_scaled-class_method" title="bessel_In_scaled (class method)">.<strong>bessel_In_scaled</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of order n, \exp(-</td>
      <td>x</td>
      <td>) I_n(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_scaled_array-class_method" title="bessel_In_scaled_array (class method)">.<strong>bessel_In_scaled_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>This routine computes the values of the scaled regular cylindrical Bessel functions \exp(-</td>
      <td>x</td>
      <td>) I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_scaled_e-class_method" title="bessel_In_scaled_e (class method)">.<strong>bessel_In_scaled_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of order n, \exp(-</td>
      <td>x</td>
      <td>) I_n(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu-class_method" title="bessel_Inu (class method)">.<strong>bessel_Inu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified Bessel function of fractional order \nu, I_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu_e-class_method" title="bessel_Inu_e (class method)">.<strong>bessel_Inu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified Bessel function of fractional order \nu, I_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu_scaled-class_method" title="bessel_Inu_scaled (class method)">.<strong>bessel_Inu_scaled</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified Bessel function of fractional order \nu, \exp(-</td>
      <td>x</td>
      <td>)I_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu_scaled_e-class_method" title="bessel_Inu_scaled_e (class method)">.<strong>bessel_Inu_scaled_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified Bessel function of fractional order \nu, \exp(-</td>
      <td>x</td>
      <td>)I_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J0-class_method" title="bessel_J0 (class method)">.<strong>bessel_J0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of zeroth order, J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j0-class_method" title="bessel_j0 (class method)">.<strong>bessel_j0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of zeroth order, j_0(x) = \sin(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J0_e-class_method" title="bessel_J0_e (class method)">.<strong>bessel_J0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of zeroth order, J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j0_e-class_method" title="bessel_j0_e (class method)">.<strong>bessel_j0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of zeroth order, j_0(x) = \sin(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J1-class_method" title="bessel_J1 (class method)">.<strong>bessel_J1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of first order, J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j1-class_method" title="bessel_j1 (class method)">.<strong>bessel_j1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of first order, j_1(x) = (\sin(x)/x - \cos(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J1_e-class_method" title="bessel_J1_e (class method)">.<strong>bessel_J1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of first order, J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j1_e-class_method" title="bessel_j1_e (class method)">.<strong>bessel_j1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of first order, j_1(x) = (\sin(x)/x - \cos(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j2-class_method" title="bessel_j2 (class method)">.<strong>bessel_j2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j2_e-class_method" title="bessel_j2_e (class method)">.<strong>bessel_j2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl-class_method" title="bessel_jl (class method)">.<strong>bessel_jl</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of order l, j_l(x), for $l \geq 0$ l &gt;= 0 and $x \geq 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl_array-class_method" title="bessel_jl_array (class method)">.<strong>bessel_jl_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive  for $lmax \geq 0$ lmax &gt;= 0 and $x \geq 0$ x &gt;= 0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl_e-class_method" title="bessel_jl_e (class method)">.<strong>bessel_jl_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of order l, j_l(x), for $l \geq 0$ l &gt;= 0 and $x \geq 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl_steed_array-class_method" title="bessel_jl_steed_array (class method)">.<strong>bessel_jl_steed_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine uses Steed’s method to compute the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive for $lmax \geq 0$ lmax &gt;= 0 and $x \geq 0$ x &gt;= 0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jn-class_method" title="bessel_Jn (class method)">.<strong>bessel_Jn</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of order n, J_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jn_array-class_method" title="bessel_Jn_array (class method)">.<strong>bessel_Jn_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the regular cylindrical Bessel functions J_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jn_e-class_method" title="bessel_Jn_e (class method)">.<strong>bessel_Jn_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of order n, J_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jnu-class_method" title="bessel_Jnu (class method)">.<strong>bessel_Jnu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of fractional order \nu, J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jnu_e-class_method" title="bessel_Jnu_e (class method)">.<strong>bessel_Jnu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of fractional order \nu, J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0-class_method" title="bessel_K0 (class method)">.<strong>bessel_K0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0_e-class_method" title="bessel_K0_e (class method)">.<strong>bessel_K0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0_scaled-class_method" title="bessel_K0_scaled (class method)">.<strong>bessel_K0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of zeroth order \exp(x) K_0(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k0_scaled-class_method" title="bessel_k0_scaled (class method)">.<strong>bessel_k0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of zeroth order, \exp(x) k_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0_scaled_e-class_method" title="bessel_K0_scaled_e (class method)">.<strong>bessel_K0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of zeroth order \exp(x) K_0(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k0_scaled_e-class_method" title="bessel_k0_scaled_e (class method)">.<strong>bessel_k0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of zeroth order, \exp(x) k_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1-class_method" title="bessel_K1 (class method)">.<strong>bessel_K1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of first order, K_1(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1_e-class_method" title="bessel_K1_e (class method)">.<strong>bessel_K1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of first order, K_1(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1_scaled-class_method" title="bessel_K1_scaled (class method)">.<strong>bessel_K1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of first order \exp(x) K_1(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k1_scaled-class_method" title="bessel_k1_scaled (class method)">.<strong>bessel_k1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of first order, \exp(x) k_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1_scaled_e-class_method" title="bessel_K1_scaled_e (class method)">.<strong>bessel_K1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of first order \exp(x) K_1(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k1_scaled_e-class_method" title="bessel_k1_scaled_e (class method)">.<strong>bessel_k1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of first order, \exp(x) k_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k2_scaled-class_method" title="bessel_k2_scaled (class method)">.<strong>bessel_k2_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of second order, \exp(x) k_2(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k2_scaled_e-class_method" title="bessel_k2_scaled_e (class method)">.<strong>bessel_k2_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of second order, \exp(x) k_2(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_kl_scaled-class_method" title="bessel_kl_scaled (class method)">.<strong>bessel_kl_scaled</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of order l, \exp(x) k_l(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_kl_scaled_array-class_method" title="bessel_kl_scaled_array (class method)">.<strong>bessel_kl_scaled_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the scaled irregular modified spherical Bessel functions \exp(x) k_l(x) for l from 0 to lmax inclusive for $lmax \geq 0$ lmax &gt;= 0 and x&gt;0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_kl_scaled_e-class_method" title="bessel_kl_scaled_e (class method)">.<strong>bessel_kl_scaled_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of order l, \exp(x) k_l(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn-class_method" title="bessel_Kn (class method)">.<strong>bessel_Kn</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of order n, K_n(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_array-class_method" title="bessel_Kn_array (class method)">.<strong>bessel_Kn_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the irregular modified cylindrical Bessel functions K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_e-class_method" title="bessel_Kn_e (class method)">.<strong>bessel_Kn_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of order n, K_n(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_scaled-class_method" title="bessel_Kn_scaled (class method)">.<strong>bessel_Kn_scaled</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of order n, \exp(x) K_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_scaled_array-class_method" title="bessel_Kn_scaled_array (class method)">.<strong>bessel_Kn_scaled_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the scaled irregular cylindrical Bessel functions \exp(x) K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_scaled_e-class_method" title="bessel_Kn_scaled_e (class method)">.<strong>bessel_Kn_scaled_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of order n, \exp(x) K_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu-class_method" title="bessel_Knu (class method)">.<strong>bessel_Knu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified Bessel function of fractional order \nu, K_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu_e-class_method" title="bessel_Knu_e (class method)">.<strong>bessel_Knu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified Bessel function of fractional order \nu, K_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu_scaled-class_method" title="bessel_Knu_scaled (class method)">.<strong>bessel_Knu_scaled</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled irregular modified Bessel function of fractional order \nu, \exp(+</td>
      <td>x</td>
      <td>) K_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu_scaled_e-class_method" title="bessel_Knu_scaled_e (class method)">.<strong>bessel_Knu_scaled_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled irregular modified Bessel function of fractional order \nu, \exp(+</td>
      <td>x</td>
      <td>) K_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_lnKnu-class_method" title="bessel_lnKnu (class method)">.<strong>bessel_lnKnu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the irregular modified Bessel function of fractional order \nu, \ln(K_\nu(x)) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_lnKnu_e-class_method" title="bessel_lnKnu_e (class method)">.<strong>bessel_lnKnu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the irregular modified Bessel function of fractional order \nu, \ln(K_\nu(x)) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y0-class_method" title="bessel_Y0 (class method)">.<strong>bessel_Y0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y0-class_method" title="bessel_y0 (class method)">.<strong>bessel_y0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of zeroth order, y_0(x) = -\cos(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y0_e-class_method" title="bessel_Y0_e (class method)">.<strong>bessel_Y0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y0_e-class_method" title="bessel_y0_e (class method)">.<strong>bessel_y0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of zeroth order, y_0(x) = -\cos(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y1-class_method" title="bessel_Y1 (class method)">.<strong>bessel_Y1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of first order, Y_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y1-class_method" title="bessel_y1 (class method)">.<strong>bessel_y1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of first order, y_1(x) = -(\cos(x)/x + \sin(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y1_e-class_method" title="bessel_Y1_e (class method)">.<strong>bessel_Y1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of first order, Y_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y1_e-class_method" title="bessel_y1_e (class method)">.<strong>bessel_y1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of first order, y_1(x) = -(\cos(x)/x + \sin(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y2-class_method" title="bessel_y2 (class method)">.<strong>bessel_y2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y2_e-class_method" title="bessel_y2_e (class method)">.<strong>bessel_y2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_yl-class_method" title="bessel_yl (class method)">.<strong>bessel_yl</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of order l, y_l(x), for $l \geq 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_yl_array-class_method" title="bessel_yl_array (class method)">.<strong>bessel_yl_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the irregular spherical Bessel functions y_l(x) for l from 0 to lmax inclusive  for $lmax \geq 0$ lmax &gt;= 0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_yl_e-class_method" title="bessel_yl_e (class method)">.<strong>bessel_yl_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of order l, y_l(x), for $l \geq 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Yn-class_method" title="bessel_Yn (class method)">.<strong>bessel_Yn</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of order n, Y_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Yn_array-class_method" title="bessel_Yn_array (class method)">.<strong>bessel_Yn_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the irregular cylindrical Bessel functions Y_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Yn_e-class_method" title="bessel_Yn_e (class method)">.<strong>bessel_Yn_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of order n, Y_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Ynu-class_method" title="bessel_Ynu (class method)">.<strong>bessel_Ynu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of fractional order \nu, Y_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Ynu_e-class_method" title="bessel_Ynu_e (class method)">.<strong>bessel_Ynu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of fractional order \nu, Y_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J0-class_method" title="bessel_zero_J0 (class method)">.<strong>bessel_zero_J0</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J0_e-class_method" title="bessel_zero_J0_e (class method)">.<strong>bessel_zero_J0_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J1-class_method" title="bessel_zero_J1 (class method)">.<strong>bessel_zero_J1</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J1_e-class_method" title="bessel_zero_J1_e (class method)">.<strong>bessel_zero_J1_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_Jnu-class_method" title="bessel_zero_Jnu (class method)">.<strong>bessel_zero_Jnu</strong>(nu, s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_Jnu_e-class_method" title="bessel_zero_Jnu_e (class method)">.<strong>bessel_zero_Jnu_e</strong>(nu, s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta-class_method" title="beta (class method)">.<strong>beta</strong>(a, b)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Beta Function, B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta_e-class_method" title="beta_e (class method)">.<strong>beta_e</strong>(a, b)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Beta Function, B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta_inc-class_method" title="beta_inc (class method)">.<strong>beta_inc</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$ B_x(a,b) = \int_0^x t^[a-1] (1-t)^[b-1] dt for $0 \le x \le 1$ 0 &lt;= x &lt;= 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta_inc_e-class_method" title="beta_inc_e (class method)">.<strong>beta_inc_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$ B_x(a,b) = \int_0^x t^[a-1] (1-t)^[b-1] dt for $0 \le x \le 1$ 0 &lt;= x &lt;= 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Chi-class_method" title="Chi (class method)">.<strong>Chi</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Sf.Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$ Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] , where \gamma_E is the Euler constant (available as the macro M_EULER).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Chi_e-class_method" title="Chi_e (class method)">.<strong>Chi_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Sf.Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$ Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] , where \gamma_E is the Euler constant (available as the macro M_EULER).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#choose-class_method" title="choose (class method)">.<strong>choose</strong>(n, m)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the combinatorial factor n choose m = n!/(m!(n-m)!) exceptions: GSL_EDOM, GSL_EOVRFLW.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#choose_e-class_method" title="choose_e (class method)">.<strong>choose_e</strong>(n, m)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the combinatorial factor n choose m = n!/(m!(n-m)!) exceptions: GSL_EDOM, GSL_EOVRFLW.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Ci-class_method" title="Ci (class method)">.<strong>Ci</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Sf.Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$ Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Ci_e-class_method" title="Ci_e (class method)">.<strong>Ci_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Sf.Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$ Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#clausen-class_method" title="clausen (class method)">.<strong>clausen</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Clausen integral Cl_2(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#clausen_e-class_method" title="clausen_e (class method)">.<strong>clausen_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Clausen integral Cl_2(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_cos_e-class_method" title="complex_cos_e (class method)">.<strong>complex_cos_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the complex cosine, \cos(z_r + i z_i) storing the real and imaginary parts in czr, czi.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_dilog_e-class_method" title="complex_dilog_e (class method)">.<strong>complex_dilog_e</strong>(r, theta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the full complex-valued dilogarithm for the complex argument z = r \exp(i \theta).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_log_e-class_method" title="complex_log_e (class method)">.<strong>complex_log_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the complex logarithm of z = z_r + i z_i.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_logsin_e-class_method" title="complex_logsin_e (class method)">.<strong>complex_logsin_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the logarithm of the complex sine, \log(\sin(z_r + i z_i)) storing the real and imaginary parts in lszr, lszi.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_sin_e-class_method" title="complex_sin_e (class method)">.<strong>complex_sin_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the complex sine, \sin(z_r + i z_i) storing the real and imaginary parts in szr, szi.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_0-class_method" title="conicalP_0 (class method)">.<strong>conicalP_0</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^0<em>+ i \lambda(x)$ P^0</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_0_e-class_method" title="conicalP_0_e (class method)">.<strong>conicalP_0_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^0<em>+ i \lambda(x)$ P^0</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_1-class_method" title="conicalP_1 (class method)">.<strong>conicalP_1</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^1<em>+ i \lambda(x)$ P^1</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_1_e-class_method" title="conicalP_1_e (class method)">.<strong>conicalP_1_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^1<em>+ i \lambda(x)$ P^1</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_cyl_reg-class_method" title="conicalP_cyl_reg (class method)">.<strong>conicalP_cyl_reg</strong>(m, lambda, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Cylindrical Conical Function $P^-m<em>+ i \lambda(x)$ P^[-m]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1, $m \ge -1$ m &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_cyl_reg_e-class_method" title="conicalP_cyl_reg_e (class method)">.<strong>conicalP_cyl_reg_e</strong>(m, lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Cylindrical Conical Function $P^-m<em>+ i \lambda(x)$ P^[-m]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1, $m \ge -1$ m &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_half-class_method" title="conicalP_half (class method)">.<strong>conicalP_half</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular Spherical Conical Function $P^1/2<em>+ i \lambda(x)$ P^[1/2]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_half_e-class_method" title="conicalP_half_e (class method)">.<strong>conicalP_half_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular Spherical Conical Function $P^1/2<em>+ i \lambda(x)$ P^[1/2]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_mhalf-class_method" title="conicalP_mhalf (class method)">.<strong>conicalP_mhalf</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular Spherical Conical Function $P^-1/2<em>+ i \lambda(x)$ P^[-1/2]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_mhalf_e-class_method" title="conicalP_mhalf_e (class method)">.<strong>conicalP_mhalf_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular Spherical Conical Function $P^-1/2<em>+ i \lambda(x)$ P^[-1/2]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_sph_reg-class_method" title="conicalP_sph_reg (class method)">.<strong>conicalP_sph_reg</strong>(l, lambda, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Spherical Conical Function $P^-1/2-l<em>+ i \lambda(x)$ P^[-1/2-l]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1, $l \ge -1$ l &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_sph_reg_e-class_method" title="conicalP_sph_reg_e (class method)">.<strong>conicalP_sph_reg_e</strong>(l, lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Spherical Conical Function $P^-1/2-l<em>+ i \lambda(x)$ P^[-1/2-l]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1, $l \ge -1$ l &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cos-class_method" title="cos (class method)">.<strong>cos</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the cosine function \cos(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cos_e-class_method" title="cos_e (class method)">.<strong>cos_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the cosine function \cos(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cos_err_e-class_method" title="cos_err_e (class method)">.<strong>cos_err_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the cosine of an angle x with an associated absolute error dx, $\cos(x \pm dx)$ \cos(x \pm dx).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_CL_array-class_method" title="coulomb_CL_array (class method)">.<strong>coulomb_CL_array</strong>(Lmin, kmax, eta)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function normalization constant C_L(\eta) for L = Lmin \dots Lmin + kmax, Lmin &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_CL_e-class_method" title="coulomb_CL_e (class method)">.<strong>coulomb_CL_e</strong>(L, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function normalization constant C_L(\eta) for L &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_F_array-class_method" title="coulomb_wave_F_array (class method)">.<strong>coulomb_wave_F_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function F_L(\eta,x) for L = Lmin \dots Lmin + kmax, storing the results in fc_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_FG_array-class_method" title="coulomb_wave_FG_array (class method)">.<strong>coulomb_wave_FG_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the functions F_L(\eta,x), G_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the results in fc_array and gc_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_FG_e-class_method" title="coulomb_wave_FG_e (class method)">.<strong>coulomb_wave_FG_e</strong>(eta, x, L_F, k)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave functions F_L(\eta,x), $G_L-k(\eta,x)$ G_<a href="\eta,x">L-k</a> and their derivatives F’<em>L(\eta,x), $G’</em>L-k(\eta,x)$ G’_<a href="\eta,x">L-k</a> with respect to x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_FGp_array-class_method" title="coulomb_wave_FGp_array (class method)">.<strong>coulomb_wave_FGp_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the functions F_L(\eta,x), G_L(\eta,x) and their derivatives F’_L(\eta,x), G’_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the results in fc_array, gc_array, fcp_array and gcp_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_sphF_array-class_method" title="coulomb_wave_sphF_array (class method)">.<strong>coulomb_wave_sphF_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function divided by the argument F_L(\eta, x)/x for L = Lmin \dots Lmin + kmax, storing the results in fc_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_3j-class_method" title="coupling_3j (class method)">.<strong>coupling_3j</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; Float </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 3-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_3j_e-class_method" title="coupling_3j_e (class method)">.<strong>coupling_3j_e</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 3-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_6j-class_method" title="coupling_6j (class method)">.<strong>coupling_6j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; Float </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 6-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_6j_e-class_method" title="coupling_6j_e (class method)">.<strong>coupling_6j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 6-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_9j-class_method" title="coupling_9j (class method)">.<strong>coupling_9j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; Float </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 9-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_9j_e-class_method" title="coupling_9j_e (class method)">.<strong>coupling_9j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 9-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dawson-class_method" title="dawson (class method)">.<strong>dawson</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the value of Dawson’s integral for x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dawson_e-class_method" title="dawson_e (class method)">.<strong>dawson_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the value of Dawson’s integral for x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_1-class_method" title="debye_1 (class method)">.<strong>debye_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first-order Debye function D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_1_e-class_method" title="debye_1_e (class method)">.<strong>debye_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first-order Debye function D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_2-class_method" title="debye_2 (class method)">.<strong>debye_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order Debye function D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_2_e-class_method" title="debye_2_e (class method)">.<strong>debye_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order Debye function D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_3-class_method" title="debye_3 (class method)">.<strong>debye_3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order Debye function D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_3_e-class_method" title="debye_3_e (class method)">.<strong>debye_3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order Debye function D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_4-class_method" title="debye_4 (class method)">.<strong>debye_4</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fourth-order Debye function D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_4_e-class_method" title="debye_4_e (class method)">.<strong>debye_4_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fourth-order Debye function D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_5-class_method" title="debye_5 (class method)">.<strong>debye_5</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fifth-order Debye function D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_5_e-class_method" title="debye_5_e (class method)">.<strong>debye_5_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fifth-order Debye function D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_6-class_method" title="debye_6 (class method)">.<strong>debye_6</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sixth-order Debye function D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_6_e-class_method" title="debye_6_e (class method)">.<strong>debye_6_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sixth-order Debye function D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dilog-class_method" title="dilog (class method)">.<strong>dilog</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the dilogarithm for a real argument.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dilog_e-class_method" title="dilog_e (class method)">.<strong>dilog_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the dilogarithm for a real argument.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#doublefact-class_method" title="doublefact (class method)">.<strong>doublefact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#doublefact_e-class_method" title="doublefact_e (class method)">.<strong>doublefact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_D-class_method" title="ellint_D (class method)">.<strong>ellint_D</strong>(phi, k, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the incomplete elliptic integral D(\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_D_e-class_method" title="ellint_D_e (class method)">.<strong>ellint_D_e</strong>(phi, k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the incomplete elliptic integral D(\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_E-class_method" title="ellint_E (class method)">.<strong>ellint_E</strong>(phi, k, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral E(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_E_e-class_method" title="ellint_E_e (class method)">.<strong>ellint_E_e</strong>(phi, k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral E(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Ecomp-class_method" title="ellint_Ecomp (class method)">.<strong>ellint_Ecomp</strong>(k[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral E(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Ecomp_e-class_method" title="ellint_Ecomp_e (class method)">.<strong>ellint_Ecomp_e</strong>(k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral E(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_F-class_method" title="ellint_F (class method)">.<strong>ellint_F</strong>(phi, k, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral F(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_F_e-class_method" title="ellint_F_e (class method)">.<strong>ellint_F_e</strong>(phi, k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral F(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Kcomp-class_method" title="ellint_Kcomp (class method)">.<strong>ellint_Kcomp</strong>(k[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral K(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Kcomp_e-class_method" title="ellint_Kcomp_e (class method)">.<strong>ellint_Kcomp_e</strong>(k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral K(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_P-class_method" title="ellint_P (class method)">.<strong>ellint_P</strong>(phi, k, n, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_P_e-class_method" title="ellint_P_e (class method)">.<strong>ellint_P_e</strong>(phi, k, n, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Pcomp-class_method" title="ellint_Pcomp (class method)">.<strong>ellint_Pcomp</strong>(k, n, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral \Pi(k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Pcomp_e-class_method" title="ellint_Pcomp_e (class method)">.<strong>ellint_Pcomp_e</strong>(k, n, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral \Pi(k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RC-class_method" title="ellint_RC (class method)">.<strong>ellint_RC</strong>(x, y, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RC_e-class_method" title="ellint_RC_e (class method)">.<strong>ellint_RC_e</strong>(x, y, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RD-class_method" title="ellint_RD (class method)">.<strong>ellint_RD</strong>(x, y, z, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RD_e-class_method" title="ellint_RD_e (class method)">.<strong>ellint_RD_e</strong>(x, y, z, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RF-class_method" title="ellint_RF (class method)">.<strong>ellint_RF</strong>(x, y, z, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RF_e-class_method" title="ellint_RF_e (class method)">.<strong>ellint_RF_e</strong>(x, y, z, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RJ-class_method" title="ellint_RJ (class method)">.<strong>ellint_RJ</strong>(x, y, z, p, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RJ_e-class_method" title="ellint_RJ_e (class method)">.<strong>ellint_RJ_e</strong>(x, y, z, p, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#elljac_e-class_method" title="elljac_e (class method)">.<strong>elljac_e</strong>(u, m)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>This function computes the Jacobian elliptic functions sn(u</td>
      <td>m), cn(u</td>
      <td>m), dn(u</td>
      <td>m) by descending Landen transformations.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf-class_method" title="erf (class method)">.<strong>erf</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the error function $\erf(x)$ erf(x), where $\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$ erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_e-class_method" title="erf_e (class method)">.<strong>erf_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the error function $\erf(x)$ erf(x), where $\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$ erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Q-class_method" title="erf_Q (class method)">.<strong>erf_Q</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the upper tail of the Gaussian probability function $Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$ Q(x) = (1/\sqrt[2\pi]) \int_x^\infty dt \exp(-t^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Q_e-class_method" title="erf_Q_e (class method)">.<strong>erf_Q_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the upper tail of the Gaussian probability function $Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$ Q(x) = (1/\sqrt[2\pi]) \int_x^\infty dt \exp(-t^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Z-class_method" title="erf_Z (class method)">.<strong>erf_Z</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gaussian probability density function $Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$ Z(x) = (1/\sqrt[2\pi]) \exp(-x^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Z_e-class_method" title="erf_Z_e (class method)">.<strong>erf_Z_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gaussian probability density function $Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$ Z(x) = (1/\sqrt[2\pi]) \exp(-x^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erfc-class_method" title="erfc (class method)">.<strong>erfc</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary error function $\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$ erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erfc_e-class_method" title="erfc_e (class method)">.<strong>erfc_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary error function $\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$ erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta-class_method" title="eta (class method)">.<strong>eta</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(s) for arbitrary s.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta_e-class_method" title="eta_e (class method)">.<strong>eta_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(s) for arbitrary s.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta_int-class_method" title="eta_int (class method)">.<strong>eta_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(n) for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta_int_e-class_method" title="eta_int_e (class method)">.<strong>eta_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(n) for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp-class_method" title="exp (class method)">.<strong>exp</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines provide an exponential function \exp(x) using GSL semantics and error checking.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_e-class_method" title="exp_e (class method)">.<strong>exp_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines provide an exponential function \exp(x) using GSL semantics and error checking.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_e10_e-class_method" title="exp_e10_e (class method)">.<strong>exp_e10_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the exponential \exp(x) using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_err_e-class_method" title="exp_err_e (class method)">.<strong>exp_err_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function exponentiates x with an associated absolute error dx.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_err_e10_e-class_method" title="exp_err_e10_e (class method)">.<strong>exp_err_e10_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function exponentiates a quantity x with an associated absolute error dx using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult-class_method" title="exp_mult (class method)">.<strong>exp_mult</strong>(x, y)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines exponentiate x and multiply by the factor y to return the product y \exp(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_e-class_method" title="exp_mult_e (class method)">.<strong>exp_mult_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines exponentiate x and multiply by the factor y to return the product y \exp(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_e10_e-class_method" title="exp_mult_e10_e (class method)">.<strong>exp_mult_e10_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the product y \exp(x) using the gsl_sf_result_e10 type to return a result with extended numeric range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_err_e-class_method" title="exp_mult_err_e (class method)">.<strong>exp_mult_err_e</strong>(x, dx, y, dy)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the product y \exp(x) for the quantities x, y with associated absolute errors dx, dy.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_err_e10_e-class_method" title="exp_mult_err_e10_e (class method)">.<strong>exp_mult_err_e10_e</strong>(x, dx, y, dy)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the product y \exp(x) for the quantities x, y with associated absolute errors dx, dy using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_3-class_method" title="expint_3 (class method)">.<strong>expint_3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$ Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_3_e-class_method" title="expint_3_e (class method)">.<strong>expint_3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$ Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E1-class_method" title="expint_E1 (class method)">.<strong>expint_E1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_1(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E1_e-class_method" title="expint_E1_e (class method)">.<strong>expint_E1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_1(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E2-class_method" title="expint_E2 (class method)">.<strong>expint_E2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order exponential integral E_2(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E2_e-class_method" title="expint_E2_e (class method)">.<strong>expint_E2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order exponential integral E_2(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_Ei-class_method" title="expint_Ei (class method)">.<strong>expint_Ei</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral $\hboxEi(x)$ Ei(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_Ei_e-class_method" title="expint_Ei_e (class method)">.<strong>expint_Ei_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral $\hboxEi(x)$ Ei(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_En-class_method" title="expint_En (class method)">.<strong>expint_En</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_n(x) of order n,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_En_e-class_method" title="expint_En_e (class method)">.<strong>expint_En_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_n(x) of order n,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expm1-class_method" title="expm1 (class method)">.<strong>expm1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity \exp(x)-1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expm1_e-class_method" title="expm1_e (class method)">.<strong>expm1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity \exp(x)-1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel-class_method" title="exprel (class method)">.<strong>exprel</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity (\exp(x)-1)/x using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_2-class_method" title="exprel_2 (class method)">.<strong>exprel_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_2_e-class_method" title="exprel_2_e (class method)">.<strong>exprel_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_e-class_method" title="exprel_e (class method)">.<strong>exprel_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity (\exp(x)-1)/x using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_n-class_method" title="exprel_n (class method)">.<strong>exprel_n</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_n_e-class_method" title="exprel_n_e (class method)">.<strong>exprel_n_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fact-class_method" title="fact (class method)">.<strong>fact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the factorial n!.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fact_e-class_method" title="fact_e (class method)">.<strong>fact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the factorial n!.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_0-class_method" title="fermi_dirac_0 (class method)">.<strong>fermi_dirac_0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_0_e-class_method" title="fermi_dirac_0_e (class method)">.<strong>fermi_dirac_0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_1-class_method" title="fermi_dirac_1 (class method)">.<strong>fermi_dirac_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 1, F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_1_e-class_method" title="fermi_dirac_1_e (class method)">.<strong>fermi_dirac_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 1, F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_2-class_method" title="fermi_dirac_2 (class method)">.<strong>fermi_dirac_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_2_e-class_method" title="fermi_dirac_2_e (class method)">.<strong>fermi_dirac_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_3half-class_method" title="fermi_dirac_3half (class method)">.<strong>fermi_dirac_3half</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_3/2(x)$ F_<a href="x">3/2</a>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_3half_e-class_method" title="fermi_dirac_3half_e (class method)">.<strong>fermi_dirac_3half_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_3/2(x)$ F_<a href="x">3/2</a>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_half-class_method" title="fermi_dirac_half (class method)">.<strong>fermi_dirac_half</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_1/2(x)$ F_<a href="x">1/2</a>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_half_e-class_method" title="fermi_dirac_half_e (class method)">.<strong>fermi_dirac_half_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_1/2(x)$ F_<a href="x">1/2</a>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_inc_0-class_method" title="fermi_dirac_inc_0 (class method)">.<strong>fermi_dirac_inc_0</strong>(x, b)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete Fermi-Dirac integral with an index of zero, $F_0(x,b) = \ln(1 + e^b-x) - (b-x)$ F_0(x,b) = \ln(1 + e^[b-x]) - (b-x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_inc_0_e-class_method" title="fermi_dirac_inc_0_e (class method)">.<strong>fermi_dirac_inc_0_e</strong>(x, b)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete Fermi-Dirac integral with an index of zero, $F_0(x,b) = \ln(1 + e^b-x) - (b-x)$ F_0(x,b) = \ln(1 + e^[b-x]) - (b-x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_int-class_method" title="fermi_dirac_int (class method)">.<strong>fermi_dirac_int</strong>(j, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_int_e-class_method" title="fermi_dirac_int_e (class method)">.<strong>fermi_dirac_int_e</strong>(j, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_m1-class_method" title="fermi_dirac_m1 (class method)">.<strong>fermi_dirac_m1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_m1_e-class_method" title="fermi_dirac_m1_e (class method)">.<strong>fermi_dirac_m1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_mhalf-class_method" title="fermi_dirac_mhalf (class method)">.<strong>fermi_dirac_mhalf</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_-1/2(x)$ F_<a href="x">-1/2</a>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_mhalf_e-class_method" title="fermi_dirac_mhalf_e (class method)">.<strong>fermi_dirac_mhalf_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_-1/2(x)$ F_<a href="x">-1/2</a>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma-class_method" title="gamma (class method)">.<strong>gamma</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gamma function \Gamma(x), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_e-class_method" title="gamma_e (class method)">.<strong>gamma_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gamma function \Gamma(x), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc-class_method" title="gamma_inc (class method)">.<strong>gamma_inc</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the unnormalized incomplete Gamma Function $\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$ \Gamma(a,x) = \int_x^\infty dt t^[a-1] \exp(-t) for a real and $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_e-class_method" title="gamma_inc_e (class method)">.<strong>gamma_inc_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the unnormalized incomplete Gamma Function $\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$ \Gamma(a,x) = \int_x^\infty dt t^[a-1] \exp(-t) for a real and $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_P-class_method" title="gamma_inc_P (class method)">.<strong>gamma_inc_P</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary normalized incomplete Gamma Function $P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$ P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^[a-1] \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_P_e-class_method" title="gamma_inc_P_e (class method)">.<strong>gamma_inc_P_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary normalized incomplete Gamma Function $P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$ P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^[a-1] \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_Q-class_method" title="gamma_inc_Q (class method)">.<strong>gamma_inc_Q</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Gamma Function $Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$ Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^[a-1] \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_Q_e-class_method" title="gamma_inc_Q_e (class method)">.<strong>gamma_inc_Q_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Gamma Function $Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$ Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^[a-1] \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammainv-class_method" title="gammainv (class method)">.<strong>gammainv</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the reciprocal of the gamma function, 1/\Gamma(x) using the real Lanczos method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammainv_e-class_method" title="gammainv_e (class method)">.<strong>gammainv_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the reciprocal of the gamma function, 1/\Gamma(x) using the real Lanczos method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammastar-class_method" title="gammastar (class method)">.<strong>gammastar</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regulated Gamma Function \Gamma^*(x) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammastar_e-class_method" title="gammastar_e (class method)">.<strong>gammastar_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regulated Gamma Function \Gamma^*(x) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_1-class_method" title="gegenpoly_1 (class method)">.<strong>gegenpoly_1</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^[(\lambda)]_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_1_e-class_method" title="gegenpoly_1_e (class method)">.<strong>gegenpoly_1_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^[(\lambda)]_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_2-class_method" title="gegenpoly_2 (class method)">.<strong>gegenpoly_2</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^[(\lambda)]_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_2_e-class_method" title="gegenpoly_2_e (class method)">.<strong>gegenpoly_2_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^[(\lambda)]_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_3-class_method" title="gegenpoly_3 (class method)">.<strong>gegenpoly_3</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^[(\lambda)]_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_3_e-class_method" title="gegenpoly_3_e (class method)">.<strong>gegenpoly_3_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^[(\lambda)]_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_array-class_method" title="gegenpoly_array (class method)">.<strong>gegenpoly_array</strong>(nmax, lambda, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes an array of Gegenbauer polynomials $C^(\lambda)_n(x)$ C^[(\lambda)]_n(x) for n = 0, 1, 2, \dots, nmax, subject to \lambda &gt; -1/2, $nmax \ge 0$ nmax &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_n-class_method" title="gegenpoly_n (class method)">.<strong>gegenpoly_n</strong>(n, lambda, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$ C^[(\lambda)]_n(x) for a specific value of n, lambda, x subject to \lambda &gt; -1/2, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_n_e-class_method" title="gegenpoly_n_e (class method)">.<strong>gegenpoly_n_e</strong>(n, lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$ C^[(\lambda)]_n(x) for a specific value of n, lambda, x subject to \lambda &gt; -1/2, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hazard-class_method" title="hazard (class method)">.<strong>hazard</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hazard function for the normal distribution.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hazard_e-class_method" title="hazard_e (class method)">.<strong>hazard_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hazard function for the normal distribution.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR-class_method" title="hydrogenicR (class method)">.<strong>hydrogenicR</strong>(n, l, Z, r)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the n-th normalized hydrogenic bound state radial wavefunction,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR_1-class_method" title="hydrogenicR_1 (class method)">.<strong>hydrogenicR_1</strong>(Z, r)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the lowest-order normalized hydrogenic bound state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$ R_1 := 2Z \sqrt[Z] \exp(-Z r).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR_1_e-class_method" title="hydrogenicR_1_e (class method)">.<strong>hydrogenicR_1_e</strong>(Z, r)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the lowest-order normalized hydrogenic bound state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$ R_1 := 2Z \sqrt[Z] \exp(-Z r).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR_e-class_method" title="hydrogenicR_e (class method)">.<strong>hydrogenicR_e</strong>(n, l, Z, r)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the n-th normalized hydrogenic bound state radial wavefunction,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_0F1-class_method" title="hyperg_0F1 (class method)">.<strong>hyperg_0F1</strong>(c, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_0F_1(c,x)$ 0F1(c,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_0F1_e-class_method" title="hyperg_0F1_e (class method)">.<strong>hyperg_0F1_e</strong>(c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_0F_1(c,x)$ 0F1(c,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1-class_method" title="hyperg_1F1 (class method)">.<strong>hyperg_1F1</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(a,b,x) = M(a,b,x)$ 1F1(a,b,x) = M(a,b,x) for general parameters a, b.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1_e-class_method" title="hyperg_1F1_e (class method)">.<strong>hyperg_1F1_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(a,b,x) = M(a,b,x)$ 1F1(a,b,x) = M(a,b,x) for general parameters a, b.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1_int-class_method" title="hyperg_1F1_int (class method)">.<strong>hyperg_1F1_int</strong>(m, n, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(m,n,x) = M(m,n,x)$ 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1_int_e-class_method" title="hyperg_1F1_int_e (class method)">.<strong>hyperg_1F1_int_e</strong>(m, n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(m,n,x) = M(m,n,x)$ 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F0-class_method" title="hyperg_2F0 (class method)">.<strong>hyperg_2F0</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$ 2F0(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F0_e-class_method" title="hyperg_2F0_e (class method)">.<strong>hyperg_2F0_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$ 2F0(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1-class_method" title="hyperg_2F1 (class method)">.<strong>hyperg_2F1</strong>(a, b, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a,b,c,x) = F(a,b,c,x)$ 2F1(a,b,c,x) = F(a,b,c,x) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj-class_method" title="hyperg_2F1_conj (class method)">.<strong>hyperg_2F1_conj</strong>(aR, aI, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a_R + i a_I, aR - i aI, c, x)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj_e-class_method" title="hyperg_2F1_conj_e (class method)">.<strong>hyperg_2F1_conj_e</strong>(aR, aI, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a_R + i a_I, aR - i aI, c, x)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj_renorm-class_method" title="hyperg_2F1_conj_renorm (class method)">.<strong>hyperg_2F1_conj_renorm</strong>(aR, aI, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj_renorm_e-class_method" title="hyperg_2F1_conj_renorm_e (class method)">.<strong>hyperg_2F1_conj_renorm_e</strong>(aR, aI, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_e-class_method" title="hyperg_2F1_e (class method)">.<strong>hyperg_2F1_e</strong>(a, b, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a,b,c,x) = F(a,b,c,x)$ 2F1(a,b,c,x) = F(a,b,c,x) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_renorm-class_method" title="hyperg_2F1_renorm (class method)">.<strong>hyperg_2F1_renorm</strong>(a, b, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a,b,c,x) / \Gamma(c)$ 2F1(a,b,c,x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_renorm_e-class_method" title="hyperg_2F1_renorm_e (class method)">.<strong>hyperg_2F1_renorm_e</strong>(a, b, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a,b,c,x) / \Gamma(c)$ 2F1(a,b,c,x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U-class_method" title="hyperg_U (class method)">.<strong>hyperg_U</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_e-class_method" title="hyperg_U_e (class method)">.<strong>hyperg_U_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_e10_e-class_method" title="hyperg_U_e10_e (class method)">.<strong>hyperg_U_e10_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the confluent hypergeometric function U(a,b,x) using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_int-class_method" title="hyperg_U_int (class method)">.<strong>hyperg_U_int</strong>(m, n, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_int_e-class_method" title="hyperg_U_int_e (class method)">.<strong>hyperg_U_int_e</strong>(m, n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_int_e10_e-class_method" title="hyperg_U_int_e10_e (class method)">.<strong>hyperg_U_int_e10_e</strong>(m, n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hypot-class_method" title="hypot (class method)">.<strong>hypot</strong>(x, y)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypotenuse function $\sqrt+ y^2$ \sqrt[x^2 + y^2] avoiding overflow and underflow.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hypot_e-class_method" title="hypot_e (class method)">.<strong>hypot_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypotenuse function $\sqrt+ y^2$ \sqrt[x^2 + y^2] avoiding overflow and underflow.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hzeta-class_method" title="hzeta (class method)">.<strong>hzeta</strong>(s, q)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Hurwitz zeta function \zeta(s,q) for s &gt; 1, q &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hzeta_e-class_method" title="hzeta_e (class method)">.<strong>hzeta_e</strong>(s, q)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Hurwitz zeta function \zeta(s,q) for s &gt; 1, q &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_1-class_method" title="laguerre_1 (class method)">.<strong>laguerre_1</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_1_e-class_method" title="laguerre_1_e (class method)">.<strong>laguerre_1_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_2-class_method" title="laguerre_2 (class method)">.<strong>laguerre_2</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_2_e-class_method" title="laguerre_2_e (class method)">.<strong>laguerre_2_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_3-class_method" title="laguerre_3 (class method)">.<strong>laguerre_3</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_3_e-class_method" title="laguerre_3_e (class method)">.<strong>laguerre_3_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_n-class_method" title="laguerre_n (class method)">.<strong>laguerre_n</strong>(n, a, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_n(x) for a &gt; -1, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_n_e-class_method" title="laguerre_n_e (class method)">.<strong>laguerre_n_e</strong>(n, a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_n(x) for a &gt; -1, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_W0-class_method" title="lambert_W0 (class method)">.<strong>lambert_W0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the principal branch of the Lambert W function, W_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_W0_e-class_method" title="lambert_W0_e (class method)">.<strong>lambert_W0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the principal branch of the Lambert W function, W_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_Wm1-class_method" title="lambert_Wm1 (class method)">.<strong>lambert_Wm1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the secondary real-valued branch of the Lambert W function, $W_-1(x)$ W_<a href="x">-1</a>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_Wm1_e-class_method" title="lambert_Wm1_e (class method)">.<strong>lambert_Wm1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the secondary real-valued branch of the Lambert W function, $W_-1(x)$ W_<a href="x">-1</a>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array-class_method" title="legendre_array (class method)">.<strong>legendre_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre polynomials for 0 \le l \le lmax and 0 \le m \le l for $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array_e-class_method" title="legendre_array_e (class method)">.<strong>legendre_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre polynomials for 0 \le l \le lmax and 0 \le m \le l for $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array_index-class_method" title="legendre_array_index (class method)">.<strong>legendre_array_index</strong>(l, m)  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the index into result_array, result_deriv_array, or result_deriv2_array corresponding to P_l^m(x), P_l^‘m(x), or P_l^‘‘m(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array_n-class_method" title="legendre_array_n (class method)">.<strong>legendre_array_n</strong>(lmax)  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the minimum array size for maximum degree lmax needed for the array versions of the associated Legendre functions.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_alt_array-class_method" title="legendre_deriv2_alt_array (class method)">.<strong>legendre_deriv2_alt_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_alt_array_e-class_method" title="legendre_deriv2_alt_array_e (class method)">.<strong>legendre_deriv2_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_array-class_method" title="legendre_deriv2_array (class method)">.<strong>legendre_deriv2_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_array_e-class_method" title="legendre_deriv2_array_e (class method)">.<strong>legendre_deriv2_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_alt_array-class_method" title="legendre_deriv_alt_array (class method)">.<strong>legendre_deriv_alt_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_alt_array_e-class_method" title="legendre_deriv_alt_array_e (class method)">.<strong>legendre_deriv_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_array-class_method" title="legendre_deriv_array (class method)">.<strong>legendre_deriv_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_array_e-class_method" title="legendre_deriv_array_e (class method)">.<strong>legendre_deriv_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d-class_method" title="legendre_H3d (class method)">.<strong>legendre_H3d</strong>(l, lambda, eta)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$ \eta &gt;= 0, $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_0-class_method" title="legendre_H3d_0 (class method)">.<strong>legendre_H3d_0</strong>(lambda, eta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script> L^[H3d]_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_0_e-class_method" title="legendre_H3d_0_e (class method)">.<strong>legendre_H3d_0_e</strong>(lambda, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script> L^[H3d]_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_1-class_method" title="legendre_H3d_1 (class method)">.<strong>legendre_H3d_1</strong>(lambda, eta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script> L^[H3d]_1(\lambda,\eta) := 1/\sqrt[\lambda^2 + 1] \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_1_e-class_method" title="legendre_H3d_1_e (class method)">.<strong>legendre_H3d_1_e</strong>(lambda, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script> L^[H3d]_1(\lambda,\eta) := 1/\sqrt[\lambda^2 + 1] \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_array-class_method" title="legendre_H3d_array (class method)">.<strong>legendre_H3d_array</strong>(lmax, lambda, eta)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes an array of radial eigenfunctions $L^H3d_l( \lambda, \eta)$ L^[H3d]_l(\lambda, \eta) for $0 \le l \le lmax$ 0 &lt;= l &lt;= lmax.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_e-class_method" title="legendre_H3d_e (class method)">.<strong>legendre_H3d_e</strong>(l, lambda, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$ \eta &gt;= 0, $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P1-class_method" title="legendre_P1 (class method)">.<strong>legendre_P1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P1_e-class_method" title="legendre_P1_e (class method)">.<strong>legendre_P1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P2-class_method" title="legendre_P2 (class method)">.<strong>legendre_P2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P2_e-class_method" title="legendre_P2_e (class method)">.<strong>legendre_P2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P3-class_method" title="legendre_P3 (class method)">.<strong>legendre_P3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P3_e-class_method" title="legendre_P3_e (class method)">.<strong>legendre_P3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl-class_method" title="legendre_Pl (class method)">.<strong>legendre_Pl</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions evaluate the Legendre polynomial $P_l(x)$ P_l(x) for a specific value of l, x subject to $l \ge 0$ l &gt;= 0, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl_array-class_method" title="legendre_Pl_array (class method)">.<strong>legendre_Pl_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions compute arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \dots, lmax, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl_deriv_array-class_method" title="legendre_Pl_deriv_array (class method)">.<strong>legendre_Pl_deriv_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions compute arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \dots, lmax, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl_e-class_method" title="legendre_Pl_e (class method)">.<strong>legendre_Pl_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions evaluate the Legendre polynomial $P_l(x)$ P_l(x) for a specific value of l, x subject to $l \ge 0$ l &gt;= 0, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Plm-class_method" title="legendre_Plm (class method)">.<strong>legendre_Plm</strong>(l, m, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the associated Legendre polynomial P_l^m(x) for $m \ge 0$ m &gt;= 0, $l \ge m$ l &gt;= m, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Plm_e-class_method" title="legendre_Plm_e (class method)">.<strong>legendre_Plm_e</strong>(l, m, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the associated Legendre polynomial P_l^m(x) for $m \ge 0$ m &gt;= 0, $l \ge m$ l &gt;= m, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q0-class_method" title="legendre_Q0 (class method)">.<strong>legendre_Q0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_0(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q0_e-class_method" title="legendre_Q0_e (class method)">.<strong>legendre_Q0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_0(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q1-class_method" title="legendre_Q1 (class method)">.<strong>legendre_Q1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_1(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q1_e-class_method" title="legendre_Q1_e (class method)">.<strong>legendre_Q1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_1(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Ql-class_method" title="legendre_Ql (class method)">.<strong>legendre_Ql</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_l(x) for x &gt; -1, $x \ne 1$ x != 1 and $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Ql_e-class_method" title="legendre_Ql_e (class method)">.<strong>legendre_Ql_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_l(x) for x &gt; -1, $x \ne 1$ x != 1 and $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_sphPlm-class_method" title="legendre_sphPlm (class method)">.<strong>legendre_sphPlm</strong>(l, m, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized associated Legendre polynomial $\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$ \sqrt[(2l+1)/(4\pi)] \sqrt[(l-m)!/(l+m)!] P_l^m(x) suitable for use in spherical harmonics.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_sphPlm_e-class_method" title="legendre_sphPlm_e (class method)">.<strong>legendre_sphPlm_e</strong>(l, m, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized associated Legendre polynomial $\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$ \sqrt[(2l+1)/(4\pi)] \sqrt[(l-m)!/(l+m)!] P_l^m(x) suitable for use in spherical harmonics.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnbeta-class_method" title="lnbeta (class method)">.<strong>lnbeta</strong>(a, b)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Beta Function, \log(B(a,b)) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnbeta_e-class_method" title="lnbeta_e (class method)">.<strong>lnbeta_e</strong>(a, b)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Beta Function, \log(B(a,b)) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnchoose-class_method" title="lnchoose (class method)">.<strong>lnchoose</strong>(n, m)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of n choose m.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnchoose_e-class_method" title="lnchoose_e (class method)">.<strong>lnchoose_e</strong>(n, m)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of n choose m.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lncosh-class_method" title="lncosh (class method)">.<strong>lncosh</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\cosh(x)) for any x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lncosh_e-class_method" title="lncosh_e (class method)">.<strong>lncosh_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\cosh(x)) for any x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lndoublefact-class_method" title="lndoublefact (class method)">.<strong>lndoublefact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the double factorial of n, \log(n!!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lndoublefact_e-class_method" title="lndoublefact_e (class method)">.<strong>lndoublefact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the double factorial of n, \log(n!!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnfact-class_method" title="lnfact (class method)">.<strong>lnfact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the factorial of n, \log(n!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnfact_e-class_method" title="lnfact_e (class method)">.<strong>lnfact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the factorial of n, \log(n!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma-class_method" title="lngamma (class method)">.<strong>lngamma</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Gamma function, \log(\Gamma(x)), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma_complex_e-class_method" title="lngamma_complex_e (class method)">.<strong>lngamma_complex_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes \log(\Gamma(z)) for complex z=z_r+i z_i and z not a negative integer or zero, using the complex Lanczos method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma_e-class_method" title="lngamma_e (class method)">.<strong>lngamma_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Gamma function, \log(\Gamma(x)), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma_sgn_e-class_method" title="lngamma_sgn_e (class method)">.<strong>lngamma_sgn_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the sign of the gamma function and the logarithm of its magnitude, subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnpoch-class_method" title="lnpoch (class method)">.<strong>lnpoch</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Pochhammer symbol, \log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnpoch_e-class_method" title="lnpoch_e (class method)">.<strong>lnpoch_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Pochhammer symbol, \log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnpoch_sgn_e-class_method" title="lnpoch_sgn_e (class method)">.<strong>lnpoch_sgn_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sign of the Pochhammer symbol and the logarithm of its magnitude.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnsinh-class_method" title="lnsinh (class method)">.<strong>lnsinh</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\sinh(x)) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnsinh_e-class_method" title="lnsinh_e (class method)">.<strong>lnsinh_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\sinh(x)) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log-class_method" title="log (class method)">.<strong>log</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of x, \log(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx-class_method" title="log_1plusx (class method)">.<strong>log_1plusx</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx_e-class_method" title="log_1plusx_e (class method)">.<strong>log_1plusx_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx_mx-class_method" title="log_1plusx_mx (class method)">.<strong>log_1plusx_mx</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) - x for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx_mx_e-class_method" title="log_1plusx_mx_e (class method)">.<strong>log_1plusx_mx_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) - x for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_abs-class_method" title="log_abs (class method)">.<strong>log_abs</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the logarithm of the magnitude of x, \log(</td>
      <td>x</td>
      <td>), for x \ne 0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_abs_e-class_method" title="log_abs_e (class method)">.<strong>log_abs_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the logarithm of the magnitude of x, \log(</td>
      <td>x</td>
      <td>), for x \ne 0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_e-class_method" title="log_e (class method)">.<strong>log_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of x, \log(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_erfc-class_method" title="log_erfc (class method)">.<strong>log_erfc</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the complementary error function \log(\erfc(x)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_erfc_e-class_method" title="log_erfc_e (class method)">.<strong>log_erfc_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the complementary error function \log(\erfc(x)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_a-class_method" title="mathieu_a (class method)">.<strong>mathieu_a</strong>(n, q)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_a_e-class_method" title="mathieu_a_e (class method)">.<strong>mathieu_a_e</strong>(n, q)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_b-class_method" title="mathieu_b (class method)">.<strong>mathieu_b</strong>(n, q)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_b_e-class_method" title="mathieu_b_e (class method)">.<strong>mathieu_b_e</strong>(n, q)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_ce-class_method" title="mathieu_ce (class method)">.<strong>mathieu_ce</strong>(n, q, x)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_ce_e-class_method" title="mathieu_ce_e (class method)">.<strong>mathieu_ce_e</strong>(n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Mc-class_method" title="mathieu_Mc (class method)">.<strong>mathieu_Mc</strong>(j, n, q, x)  &#x21d2; Numo::Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^<a href="q,x">(j)</a> and $Ms_n^(j)(q,x)$ Ms_n^<a href="q,x">(j)</a> of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Mc_e-class_method" title="mathieu_Mc_e (class method)">.<strong>mathieu_Mc_e</strong>(j, n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^<a href="q,x">(j)</a> and $Ms_n^(j)(q,x)$ Ms_n^<a href="q,x">(j)</a> of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Ms-class_method" title="mathieu_Ms (class method)">.<strong>mathieu_Ms</strong>(j, n, q, x)  &#x21d2; Numo::Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^<a href="q,x">(j)</a> and $Ms_n^(j)(q,x)$ Ms_n^<a href="q,x">(j)</a> of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Ms_e-class_method" title="mathieu_Ms_e (class method)">.<strong>mathieu_Ms_e</strong>(j, n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^<a href="q,x">(j)</a> and $Ms_n^(j)(q,x)$ Ms_n^<a href="q,x">(j)</a> of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_se-class_method" title="mathieu_se (class method)">.<strong>mathieu_se</strong>(n, q, x)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_se_e-class_method" title="mathieu_se_e (class method)">.<strong>mathieu_se_e</strong>(n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#multiply_e-class_method" title="multiply_e (class method)">.<strong>multiply_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function multiplies x and y storing the product and its associated error in result.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#multiply_err_e-class_method" title="multiply_err_e (class method)">.<strong>multiply_err_e</strong>(x, dx, y, dy)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function multiplies x and y with associated absolute errors dx and dy.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#poch-class_method" title="poch (class method)">.<strong>poch</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#poch_e-class_method" title="poch_e (class method)">.<strong>poch_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pochrel-class_method" title="pochrel (class method)">.<strong>pochrel</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pochrel_e-class_method" title="pochrel_e (class method)">.<strong>pochrel_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#polar_to_rect-class_method" title="polar_to_rect (class method)">.<strong>polar_to_rect</strong>(r, theta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function converts the polar coordinates (r,theta) to rectilinear coordinates (x,y), x = r\cos(\theta), y = r\sin(\theta).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pow_int-class_method" title="pow_int (class method)">.<strong>pow_int</strong>(x, n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the power x^n for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pow_int_e-class_method" title="pow_int_e (class method)">.<strong>pow_int_e</strong>(x, n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the power x^n for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi-class_method" title="psi (class method)">.<strong>psi</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(x) for general x, x \ne 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1-class_method" title="psi_1 (class method)">.<strong>psi_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(x) for general x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1_e-class_method" title="psi_1_e (class method)">.<strong>psi_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(x) for general x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1_int-class_method" title="psi_1_int (class method)">.<strong>psi_1_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1_int_e-class_method" title="psi_1_int_e (class method)">.<strong>psi_1_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1piy-class_method" title="psi_1piy (class method)">.<strong>psi_1piy</strong>(y)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the real part of the digamma function on the line 1+i y, \Re[\psi(1 + i y)].</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1piy_e-class_method" title="psi_1piy_e (class method)">.<strong>psi_1piy_e</strong>(y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the real part of the digamma function on the line 1+i y, \Re[\psi(1 + i y)].</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_e-class_method" title="psi_e (class method)">.<strong>psi_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(x) for general x, x \ne 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_int-class_method" title="psi_int (class method)">.<strong>psi_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_int_e-class_method" title="psi_int_e (class method)">.<strong>psi_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_n-class_method" title="psi_n (class method)">.<strong>psi_n</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the polygamma function $\psi^(n)(x)$ \psi^<a href="x">(n)</a> for $n \ge 0$ n &gt;= 0, x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_n_e-class_method" title="psi_n_e (class method)">.<strong>psi_n_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the polygamma function $\psi^(n)(x)$ \psi^<a href="x">(n)</a> for $n \ge 0$ n &gt;= 0, x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rect_to_polar-class_method" title="rect_to_polar (class method)">.<strong>rect_to_polar</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function converts the rectilinear coordinates (x,y) to polar coordinates (r,theta), such that x = r\cos(\theta), y = r\sin(\theta).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Shi-class_method" title="Shi (class method)">.<strong>Shi</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Sf.Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$ Shi(x) = \int_0^x dt \sinh(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Shi_e-class_method" title="Shi_e (class method)">.<strong>Shi_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Sf.Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$ Shi(x) = \int_0^x dt \sinh(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Si-class_method" title="Si (class method)">.<strong>Si</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Sf.Si</a></span>(x) = \int_0^x dt \sin(t)/t$ Si(x) = \int_0^x dt \sin(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Si_e-class_method" title="Si_e (class method)">.<strong>Si_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Sf.Si</a></span>(x) = \int_0^x dt \sin(t)/t$ Si(x) = \int_0^x dt \sin(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sin-class_method" title="sin (class method)">.<strong>sin</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sine function \sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sin_e-class_method" title="sin_e (class method)">.<strong>sin_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sine function \sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sin_err_e-class_method" title="sin_err_e (class method)">.<strong>sin_err_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the sine of an angle x with an associated absolute error dx, $\sin(x \pm dx)$ \sin(x \pm dx).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sinc-class_method" title="sinc (class method)">.<strong>sinc</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any value of x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sinc_e-class_method" title="sinc_e (class method)">.<strong>sinc_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any value of x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_1-class_method" title="synchrotron_1 (class method)">.<strong>synchrotron_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first synchrotron function $x \int_x^\infty dt K_5/3(t)$ x \int_x^\infty dt K_<a href="t">5/3</a> for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_1_e-class_method" title="synchrotron_1_e (class method)">.<strong>synchrotron_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first synchrotron function $x \int_x^\infty dt K_5/3(t)$ x \int_x^\infty dt K_<a href="t">5/3</a> for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_2-class_method" title="synchrotron_2 (class method)">.<strong>synchrotron_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second synchrotron function $x K_2/3(x)$ x K_<a href="x">2/3</a> for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_2_e-class_method" title="synchrotron_2_e (class method)">.<strong>synchrotron_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second synchrotron function $x K_2/3(x)$ x K_<a href="x">2/3</a> for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#taylorcoeff-class_method" title="taylorcoeff (class method)">.<strong>taylorcoeff</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Taylor coefficient x^n / n! for $x \ge 0$ x &gt;= 0, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#taylorcoeff_e-class_method" title="taylorcoeff_e (class method)">.<strong>taylorcoeff_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Taylor coefficient x^n / n! for $x \ge 0$ x &gt;= 0, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_2-class_method" title="transport_2 (class method)">.<strong>transport_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(2,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_2_e-class_method" title="transport_2_e (class method)">.<strong>transport_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(2,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_3-class_method" title="transport_3 (class method)">.<strong>transport_3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(3,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_3_e-class_method" title="transport_3_e (class method)">.<strong>transport_3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(3,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_4-class_method" title="transport_4 (class method)">.<strong>transport_4</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(4,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_4_e-class_method" title="transport_4_e (class method)">.<strong>transport_4_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(4,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_5-class_method" title="transport_5 (class method)">.<strong>transport_5</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(5,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_5_e-class_method" title="transport_5_e (class method)">.<strong>transport_5_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(5,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta-class_method" title="zeta (class method)">.<strong>zeta</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(s) for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta_e-class_method" title="zeta_e (class method)">.<strong>zeta_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(s) for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta_int-class_method" title="zeta_int (class method)">.<strong>zeta_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(n) for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta_int_e-class_method" title="zeta_int_e (class method)">.<strong>zeta_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(n) for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1-class_method" title="zetam1 (class method)">.<strong>zetam1</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(s) - 1 for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1_e-class_method" title="zetam1_e (class method)">.<strong>zetam1_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(s) - 1 for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1_int-class_method" title="zetam1_int (class method)">.<strong>zetam1_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(n) - 1 for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1_int_e-class_method" title="zetam1_int_e (class method)">.<strong>zetam1_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(n) - 1 for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="airy_Ai-class_method">
  
    .<strong>airy_Ai</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Ai(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17739
17740
17741
17742
17743
17744
17745
17746
17747
17748
17749
17750
17751
17752
17753
17754
17755</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17739</span>

static VALUE
sf_s_airy_Ai(int argc, VALUE *v, VALUE mod)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv-class_method">
  
    .<strong>airy_Ai_deriv</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Ai’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18199
18200
18201
18202
18203
18204
18205
18206
18207
18208
18209
18210
18211
18212
18213
18214
18215</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18199</span>

static VALUE
sf_s_airy_Ai_deriv(int argc, VALUE *v, VALUE mod)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv_e-class_method">
  
    .<strong>airy_Ai_deriv_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Ai’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18252
18253
18254
18255
18256
18257
18258
18259
18260
18261
18262
18263
18264
18265
18266
18267
18268
18269
18270
18271
18272
18273
18274
18275
18276
18277</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18252</span>

static VALUE
sf_s_airy_Ai_deriv_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv_scaled-class_method">
  
    .<strong>airy_Ai_deriv_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_A(x) Ai’(x).
For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18427
18428
18429
18430
18431
18432
18433
18434
18435
18436
18437
18438
18439
18440
18441
18442
18443</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18427</span>

static VALUE
sf_s_airy_Ai_deriv_scaled(int argc, VALUE *v, VALUE mod)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv_scaled_e-class_method">
  
    .<strong>airy_Ai_deriv_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_A(x) Ai’(x).
For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18482
18483
18484
18485
18486
18487
18488
18489
18490
18491
18492
18493
18494
18495
18496
18497
18498
18499
18500
18501
18502
18503
18504
18505
18506
18507</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18482</span>

static VALUE
sf_s_airy_Ai_deriv_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_e-class_method">
  
    .<strong>airy_Ai_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Ai(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17792
17793
17794
17795
17796
17797
17798
17799
17800
17801
17802
17803
17804
17805
17806
17807
17808
17809
17810
17811
17812
17813
17814
17815
17816
17817</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17792</span>

static VALUE
sf_s_airy_Ai_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_scaled-class_method">
  
    .<strong>airy_Ai_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_A(x) Ai(x).  For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)),
and is 1
for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17968
17969
17970
17971
17972
17973
17974
17975
17976
17977
17978
17979
17980
17981
17982
17983
17984</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17968</span>

static VALUE
sf_s_airy_Ai_scaled(int argc, VALUE *v, VALUE mod)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_scaled_e-class_method">
  
    .<strong>airy_Ai_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_A(x) Ai(x).  For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)),
and is 1
for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18024
18025
18026
18027
18028
18029
18030
18031
18032
18033
18034
18035
18036
18037
18038
18039
18040
18041
18042
18043
18044
18045
18046
18047
18048
18049</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18024</span>

static VALUE
sf_s_airy_Ai_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi-class_method">
  
    .<strong>airy_Bi</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Bi(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17852
17853
17854
17855
17856
17857
17858
17859
17860
17861
17862
17863
17864
17865
17866
17867
17868</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17852</span>

static VALUE
sf_s_airy_Bi(int argc, VALUE *v, VALUE mod)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv-class_method">
  
    .<strong>airy_Bi_deriv</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Bi’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18312
18313
18314
18315
18316
18317
18318
18319
18320
18321
18322
18323
18324
18325
18326
18327
18328</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18312</span>

static VALUE
sf_s_airy_Bi_deriv(int argc, VALUE *v, VALUE mod)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv_e-class_method">
  
    .<strong>airy_Bi_deriv_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Bi’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18365
18366
18367
18368
18369
18370
18371
18372
18373
18374
18375
18376
18377
18378
18379
18380
18381
18382
18383
18384
18385
18386
18387
18388
18389
18390</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18365</span>

static VALUE
sf_s_airy_Bi_deriv_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv_scaled-class_method">
  
    .<strong>airy_Bi_deriv_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_B(x) Bi’(x).
For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18544
18545
18546
18547
18548
18549
18550
18551
18552
18553
18554
18555
18556
18557
18558
18559
18560</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18544</span>

static VALUE
sf_s_airy_Bi_deriv_scaled(int argc, VALUE *v, VALUE mod)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv_scaled_e-class_method">
  
    .<strong>airy_Bi_deriv_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_B(x) Bi’(x).
For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18599
18600
18601
18602
18603
18604
18605
18606
18607
18608
18609
18610
18611
18612
18613
18614
18615
18616
18617
18618
18619
18620
18621
18622
18623
18624</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18599</span>

static VALUE
sf_s_airy_Bi_deriv_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_e-class_method">
  
    .<strong>airy_Bi_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Bi(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17905
17906
17907
17908
17909
17910
17911
17912
17913
17914
17915
17916
17917
17918
17919
17920
17921
17922
17923
17924
17925
17926
17927
17928
17929
17930</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17905</span>

static VALUE
sf_s_airy_Bi_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_scaled-class_method">
  
    .<strong>airy_Bi_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_B(x) Bi(x).  For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18085
18086
18087
18088
18089
18090
18091
18092
18093
18094
18095
18096
18097
18098
18099
18100
18101</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18085</span>

static VALUE
sf_s_airy_Bi_scaled(int argc, VALUE *v, VALUE mod)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_scaled_e-class_method">
  
    .<strong>airy_Bi_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_B(x) Bi(x).  For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18139
18140
18141
18142
18143
18144
18145
18146
18147
18148
18149
18150
18151
18152
18153
18154
18155
18156
18157
18158
18159
18160
18161
18162
18163
18164</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18139</span>

static VALUE
sf_s_airy_Bi_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai-class_method">
  
    .<strong>airy_zero_Ai</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Ai(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18656
18657
18658
18659
18660
18661
18662
18663
18664</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18656</span>

static VALUE
sf_s_airy_zero_Ai(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai_deriv-class_method">
  
    .<strong>airy_zero_Ai_deriv</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Ai’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18828
18829
18830
18831
18832
18833
18834
18835
18836</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18828</span>

static VALUE
sf_s_airy_zero_Ai_deriv(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai_deriv_e-class_method">
  
    .<strong>airy_zero_Ai_deriv_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Ai’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18869
18870
18871
18872
18873
18874
18875
18876
18877
18878
18879
18880
18881
18882</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18869</span>

static VALUE
sf_s_airy_zero_Ai_deriv_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai_e-class_method">
  
    .<strong>airy_zero_Ai_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Ai(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18697
18698
18699
18700
18701
18702
18703
18704
18705
18706
18707
18708
18709
18710</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18697</span>

static VALUE
sf_s_airy_zero_Ai_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi-class_method">
  
    .<strong>airy_zero_Bi</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Bi(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18742
18743
18744
18745
18746
18747
18748
18749
18750</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18742</span>

static VALUE
sf_s_airy_zero_Bi(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi_deriv-class_method">
  
    .<strong>airy_zero_Bi_deriv</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Bi’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18914
18915
18916
18917
18918
18919
18920
18921
18922</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18914</span>

static VALUE
sf_s_airy_zero_Bi_deriv(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi_deriv_e-class_method">
  
    .<strong>airy_zero_Bi_deriv_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Bi’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18955
18956
18957
18958
18959
18960
18961
18962
18963
18964
18965
18966
18967
18968</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18955</span>

static VALUE
sf_s_airy_zero_Bi_deriv_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi_e-class_method">
  
    .<strong>airy_zero_Bi_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Bi(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18783
18784
18785
18786
18787
18788
18789
18790
18791
18792
18793
18794
18795
18796</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18783</span>

static VALUE
sf_s_airy_zero_Bi_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="angle_restrict_pos-class_method">
  
    .<strong>angle_restrict_pos</strong>(theta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines force the angle theta to lie in the range [0,
2\pi).</p>

<p>Note that the mathematical value of 2\pi is slightly greater
than 2<em>M_PI, so the machine number 2</em>M_PI is included in
the range.</p>

<p>Exceptional Return Values: GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1306
1307
1308
1309
1310
1311
1312
1313
1314</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1306</span>

static VALUE
sf_s_angle_restrict_pos(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_angle_restrict_pos, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="angle_restrict_symm-class_method">
  
    .<strong>angle_restrict_symm</strong>(theta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines force the angle theta to lie in the range
(-\pi,\pi].</p>

<p>Note that the mathematical value of \pi is slightly greater
than M_PI, so the machine numbers M_PI and -M_PI
are included in the range.
Exceptional Return Values: GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1261
1262
1263
1264
1265
1266
1267
1268
1269</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1261</span>

static VALUE
sf_s_angle_restrict_symm(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_angle_restrict_symm, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="atanint-class_method">
  
    .<strong>atanint</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$
AtanInt(x) = \int_0^x dt \arctan(t)/t.
Domain:
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6170
6171
6172
6173
6174
6175
6176
6177
6178</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6170</span>

static VALUE
sf_s_atanint(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_atanint, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="atanint_e-class_method">
  
    .<strong>atanint_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$
AtanInt(x) = \int_0^x dt \arctan(t)/t.
Domain:
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6213
6214
6215
6216
6217
6218
6219
6220
6221
6222
6223
6224
6225
6226</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6213</span>

static VALUE
sf_s_atanint_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_atanint_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0-class_method">
  
    .<strong>bessel_I0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of zeroth order, I_0(x).
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12856
12857
12858
12859
12860
12861
12862
12863
12864</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12856</span>

static VALUE
sf_s_bessel_I0(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0_e-class_method">
  
    .<strong>bessel_I0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of zeroth order, I_0(x).
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12898
12899
12900
12901
12902
12903
12904
12905
12906
12907
12908
12909
12910
12911</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12898</span>

static VALUE
sf_s_bessel_I0_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0_scaled-class_method">
  
    .<strong>bessel_I0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of zeroth order \exp(-|x|) I_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13205
13206
13207
13208
13209
13210
13211
13212
13213</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13205</span>

static VALUE
sf_s_bessel_I0_scaled(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i0_scaled-class_method">
  
    .<strong>bessel_i0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of zeroth order, \exp(-|x|) i_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15200
15201
15202
15203
15204
15205
15206
15207
15208</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15200</span>

static VALUE
sf_s_bessel_i0_scaled(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0_scaled_e-class_method">
  
    .<strong>bessel_I0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of zeroth order \exp(-|x|) I_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13247
13248
13249
13250
13251
13252
13253
13254
13255
13256
13257
13258
13259
13260</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13247</span>

static VALUE
sf_s_bessel_I0_scaled_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i0_scaled_e-class_method">
  
    .<strong>bessel_i0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of zeroth order, \exp(-|x|) i_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15242
15243
15244
15245
15246
15247
15248
15249
15250
15251
15252
15253
15254
15255</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15242</span>

static VALUE
sf_s_bessel_i0_scaled_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1-class_method">
  
    .<strong>bessel_I1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of first order, I_1(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12943
12944
12945
12946
12947
12948
12949
12950
12951</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12943</span>

static VALUE
sf_s_bessel_I1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1_e-class_method">
  
    .<strong>bessel_I1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of first order, I_1(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12985
12986
12987
12988
12989
12990
12991
12992
12993
12994
12995
12996
12997
12998</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12985</span>

static VALUE
sf_s_bessel_I1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1_scaled-class_method">
  
    .<strong>bessel_I1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of first order \exp(-|x|) I_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13292
13293
13294
13295
13296
13297
13298
13299
13300</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13292</span>

static VALUE
sf_s_bessel_I1_scaled(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i1_scaled-class_method">
  
    .<strong>bessel_i1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of first order, \exp(-|x|) i_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15287
15288
15289
15290
15291
15292
15293
15294
15295</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15287</span>

static VALUE
sf_s_bessel_i1_scaled(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1_scaled_e-class_method">
  
    .<strong>bessel_I1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of first order \exp(-|x|) I_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13334
13335
13336
13337
13338
13339
13340
13341
13342
13343
13344
13345
13346
13347</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13334</span>

static VALUE
sf_s_bessel_I1_scaled_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i1_scaled_e-class_method">
  
    .<strong>bessel_i1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of first order, \exp(-|x|) i_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15329
15330
15331
15332
15333
15334
15335
15336
15337
15338
15339
15340
15341
15342</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15329</span>

static VALUE
sf_s_bessel_i1_scaled_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i2_scaled-class_method">
  
    .<strong>bessel_i2_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of second order,  \exp(-|x|) i_2(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15374
15375
15376
15377
15378
15379
15380
15381
15382</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15374</span>

static VALUE
sf_s_bessel_i2_scaled(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i2_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i2_scaled_e-class_method">
  
    .<strong>bessel_i2_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of second order,  \exp(-|x|) i_2(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15416
15417
15418
15419
15420
15421
15422
15423
15424
15425
15426
15427
15428
15429</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15416</span>

static VALUE
sf_s_bessel_i2_scaled_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i2_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_il_scaled-class_method">
  
    .<strong>bessel_il_scaled</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of order l,  \exp(-|x|) i_l(x)
Domain: l &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15465
15466
15467
15468
15469
15470
15471
15472
15473
15474
15475
15476</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15465</span>

static VALUE
sf_s_bessel_il_scaled(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_il_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_il_scaled_array-class_method">
  
    .<strong>bessel_il_scaled_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled regular modified
spherical Bessel functions \exp(-|x|) i_l(x) for l from
0 to lmax inclusive for $lmax \geq 0$
lmax &gt;= 0, storing the results in
the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15577
15578
15579
15580
15581
15582
15583
15584
15585
15586
15587
15588
15589
15590
15591
15592
15593
15594
15595
15596
15597
15598
15599</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15577</span>

static VALUE
sf_s_bessel_il_scaled_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_il_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_il_scaled_e-class_method">
  
    .<strong>bessel_il_scaled_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of order l,  \exp(-|x|) i_l(x)
Domain: l &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15515
15516
15517
15518
15519
15520
15521
15522
15523
15524
15525
15526
15527
15528
15529
15530
15531
15532</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15515</span>

static VALUE
sf_s_bessel_il_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_il_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In-class_method">
  
    .<strong>bessel_In</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of order n, I_n(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13033
13034
13035
13036
13037
13038
13039
13040
13041
13042
13043
13044</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13033</span>

static VALUE
sf_s_bessel_In(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_array-class_method">
  
    .<strong>bessel_In_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the regular modified cylindrical
Bessel functions I_n(x) for n from nmin to
nmax inclusive, storing the results in the array
result_array.  The start of the range nmin must be positive
or zero.  The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: nmin &gt;=0, nmax &gt;= nmin
Conditions: n=nmin,…,nmax, nmin &gt;=0, nmax &gt;= nmin
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13148
13149
13150
13151
13152
13153
13154
13155
13156
13157
13158
13159
13160
13161
13162
13163
13164
13165
13166
13167
13168
13169
13170
13171
13172
13173</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13148</span>

static VALUE
sf_s_bessel_In_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_e-class_method">
  
    .<strong>bessel_In_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of order n, I_n(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13082
13083
13084
13085
13086
13087
13088
13089
13090
13091
13092
13093
13094
13095
13096
13097
13098
13099</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13082</span>

static VALUE
sf_s_bessel_In_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_scaled-class_method">
  
    .<strong>bessel_In_scaled</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of order n, \exp(-|x|) I_n(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13382
13383
13384
13385
13386
13387
13388
13389
13390
13391
13392
13393</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13382</span>

static VALUE
sf_s_bessel_In_scaled(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_scaled_array-class_method">
  
    .<strong>bessel_In_scaled_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled regular cylindrical
Bessel functions \exp(-|x|) I_n(x) for n from
nmin to nmax inclusive, storing the results in the array
result_array. The start of the range nmin must be positive
or zero.  The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: nmin &gt;=0, nmax &gt;= nmin
Conditions:  n=nmin,…,nmax
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13497
13498
13499
13500
13501
13502
13503
13504
13505
13506
13507
13508
13509
13510
13511
13512
13513
13514
13515
13516
13517
13518
13519
13520
13521
13522</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13497</span>

static VALUE
sf_s_bessel_In_scaled_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_scaled_e-class_method">
  
    .<strong>bessel_In_scaled_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of order n, \exp(-|x|) I_n(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13431
13432
13433
13434
13435
13436
13437
13438
13439
13440
13441
13442
13443
13444
13445
13446
13447
13448</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13431</span>

static VALUE
sf_s_bessel_In_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu-class_method">
  
    .<strong>bessel_Inu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified Bessel function of
fractional order \nu, I_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16259
16260
16261
16262
16263
16264
16265
16266
16267</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16259</span>

static VALUE
sf_s_bessel_Inu(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu_e-class_method">
  
    .<strong>bessel_Inu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified Bessel function of
fractional order \nu, I_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16306
16307
16308
16309
16310
16311
16312
16313
16314
16315
16316
16317
16318
16319</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16306</span>

static VALUE
sf_s_bessel_Inu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu_scaled-class_method">
  
    .<strong>bessel_Inu_scaled</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified Bessel function of
fractional order \nu, \exp(-|x|)I_\nu(x) for x&gt;0,
\nu&gt;0.
\exp(-|x|) I_<a href="x">\nu</a>
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16357
16358
16359
16360
16361
16362
16363
16364
16365</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16357</span>

static VALUE
sf_s_bessel_Inu_scaled(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu_scaled, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu_scaled_e-class_method">
  
    .<strong>bessel_Inu_scaled_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified Bessel function of
fractional order \nu, \exp(-|x|)I_\nu(x) for x&gt;0,
\nu&gt;0.
\exp(-|x|) I_<a href="x">\nu</a>
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16405
16406
16407
16408
16409
16410
16411
16412
16413
16414
16415
16416
16417
16418</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16405</span>

static VALUE
sf_s_bessel_Inu_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J0-class_method">
  
    .<strong>bessel_J0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of zeroth
order, J_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12163
12164
12165
12166
12167
12168
12169
12170
12171</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12163</span>

static VALUE
sf_s_bessel_J0(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j0-class_method">
  
    .<strong>bessel_j0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of zeroth
order, j_0(x) = \sin(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14266
14267
14268
14269
14270
14271
14272
14273
14274</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14266</span>

static VALUE
sf_s_bessel_j0(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J0_e-class_method">
  
    .<strong>bessel_J0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of zeroth
order, J_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12205
12206
12207
12208
12209
12210
12211
12212
12213
12214
12215
12216
12217
12218</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12205</span>

static VALUE
sf_s_bessel_J0_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j0_e-class_method">
  
    .<strong>bessel_j0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of zeroth
order, j_0(x) = \sin(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14308
14309
14310
14311
14312
14313
14314
14315
14316
14317
14318
14319
14320
14321</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14308</span>

static VALUE
sf_s_bessel_j0_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J1-class_method">
  
    .<strong>bessel_J1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of first
order, J_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12250
12251
12252
12253
12254
12255
12256
12257
12258</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12250</span>

static VALUE
sf_s_bessel_J1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j1-class_method">
  
    .<strong>bessel_j1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of first
order, j_1(x) = (\sin(x)/x - \cos(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14353
14354
14355
14356
14357
14358
14359
14360
14361</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14353</span>

static VALUE
sf_s_bessel_j1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J1_e-class_method">
  
    .<strong>bessel_J1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of first
order, J_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12292
12293
12294
12295
12296
12297
12298
12299
12300
12301
12302
12303
12304
12305</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12292</span>

static VALUE
sf_s_bessel_J1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j1_e-class_method">
  
    .<strong>bessel_j1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of first
order, j_1(x) = (\sin(x)/x - \cos(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14395
14396
14397
14398
14399
14400
14401
14402
14403
14404
14405
14406
14407
14408</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14395</span>

static VALUE
sf_s_bessel_j1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j2-class_method">
  
    .<strong>bessel_j2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of second
order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14440
14441
14442
14443
14444
14445
14446
14447
14448</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14440</span>

static VALUE
sf_s_bessel_j2(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j2_e-class_method">
  
    .<strong>bessel_j2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of second
order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14482
14483
14484
14485
14486
14487
14488
14489
14490
14491
14492
14493
14494
14495</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14482</span>

static VALUE
sf_s_bessel_j2_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl-class_method">
  
    .<strong>bessel_jl</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of
order l, j_l(x), for $l \geq 0$
l &gt;= 0 and $x \geq 0$
x &gt;= 0.
Domain: l &gt;= 0, x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14533
14534
14535
14536
14537
14538
14539
14540
14541
14542
14543
14544</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14533</span>

static VALUE
sf_s_bessel_jl(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl_array-class_method">
  
    .<strong>bessel_jl_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the regular spherical Bessel
functions j_l(x) for l from 0 to lmax
inclusive  for $lmax \geq 0$
lmax &gt;= 0 and $x \geq 0$
x &gt;= 0, storing the results in the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14647
14648
14649
14650
14651
14652
14653
14654
14655
14656
14657
14658
14659
14660
14661
14662
14663
14664
14665
14666
14667
14668
14669</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14647</span>

static VALUE
sf_s_bessel_jl_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl_e-class_method">
  
    .<strong>bessel_jl_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of
order l, j_l(x), for $l \geq 0$
l &gt;= 0 and $x \geq 0$
x &gt;= 0.
Domain: l &gt;= 0, x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14585
14586
14587
14588
14589
14590
14591
14592
14593
14594
14595
14596
14597
14598
14599
14600
14601
14602</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14585</span>

static VALUE
sf_s_bessel_jl_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl_steed_array-class_method">
  
    .<strong>bessel_jl_steed_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine uses Steed’s method to compute the values of the regular
spherical Bessel functions j_l(x) for l from 0 to
lmax inclusive for $lmax \geq 0$
lmax &gt;= 0 and $x \geq 0$
x &gt;= 0, storing the results in the array
result_array.
The Steed/Barnett algorithm is described in Comp. Phys. Comm. 21,
297 (1981).  Steed’s method is more stable than the
recurrence used in the other functions but is also slower.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14716
14717
14718
14719
14720
14721
14722
14723
14724
14725
14726
14727
14728
14729
14730
14731
14732
14733
14734
14735
14736
14737
14738</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14716</span>

static VALUE
sf_s_bessel_jl_steed_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl_steed_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jn-class_method">
  
    .<strong>bessel_Jn</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
order n, J_n(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12340
12341
12342
12343
12344
12345
12346
12347
12348
12349
12350
12351</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12340</span>

static VALUE
sf_s_bessel_Jn(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jn, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jn_array-class_method">
  
    .<strong>bessel_Jn_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the regular cylindrical Bessel
functions J_n(x) for n from nmin to nmax
inclusive, storing the results in the array result_array.  The
values are computed using recurrence relations for efficiency, and
therefore may differ slightly from the exact values.
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12452
12453
12454
12455
12456
12457
12458
12459
12460
12461
12462
12463
12464
12465
12466
12467
12468
12469
12470
12471
12472
12473
12474
12475
12476
12477</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12452</span>

static VALUE
sf_s_bessel_Jn_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jn_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jn_e-class_method">
  
    .<strong>bessel_Jn_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
order n, J_n(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12389
12390
12391
12392
12393
12394
12395
12396
12397
12398
12399
12400
12401
12402
12403
12404
12405
12406</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12389</span>

static VALUE
sf_s_bessel_Jn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jnu-class_method">
  
    .<strong>bessel_Jnu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
fractional order \nu, J_\nu(x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16071
16072
16073
16074
16075
16076
16077
16078
16079</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16071</span>

static VALUE
sf_s_bessel_Jnu(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jnu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jnu_e-class_method">
  
    .<strong>bessel_Jnu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
fractional order \nu, J_\nu(x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16116
16117
16118
16119
16120
16121
16122
16123
16124
16125
16126
16127
16128
16129</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16116</span>

static VALUE
sf_s_bessel_Jnu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jnu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0-class_method">
  
    .<strong>bessel_K0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of zeroth order, K_0(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13555
13556
13557
13558
13559
13560
13561
13562
13563</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13555</span>

static VALUE
sf_s_bessel_K0(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0_e-class_method">
  
    .<strong>bessel_K0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of zeroth order, K_0(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13598
13599
13600
13601
13602
13603
13604
13605
13606
13607
13608
13609
13610
13611</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13598</span>

static VALUE
sf_s_bessel_K0_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0_scaled-class_method">
  
    .<strong>bessel_K0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of zeroth order \exp(x) K_0(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13911
13912
13913
13914
13915
13916
13917
13918
13919</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13911</span>

static VALUE
sf_s_bessel_K0_scaled(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k0_scaled-class_method">
  
    .<strong>bessel_k0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of zeroth order, \exp(x) k_0(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15632
15633
15634
15635
15636
15637
15638
15639
15640</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15632</span>

static VALUE
sf_s_bessel_k0_scaled(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0_scaled_e-class_method">
  
    .<strong>bessel_K0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of zeroth order \exp(x) K_0(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13954
13955
13956
13957
13958
13959
13960
13961
13962
13963
13964
13965
13966
13967</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13954</span>

static VALUE
sf_s_bessel_K0_scaled_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k0_scaled_e-class_method">
  
    .<strong>bessel_k0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of zeroth order, \exp(x) k_0(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15675
15676
15677
15678
15679
15680
15681
15682
15683
15684
15685
15686
15687
15688</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15675</span>

static VALUE
sf_s_bessel_k0_scaled_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1-class_method">
  
    .<strong>bessel_K1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of first order, K_1(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13644
13645
13646
13647
13648
13649
13650
13651
13652</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13644</span>

static VALUE
sf_s_bessel_K1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1_e-class_method">
  
    .<strong>bessel_K1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of first order, K_1(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13687
13688
13689
13690
13691
13692
13693
13694
13695
13696
13697
13698
13699
13700</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13687</span>

static VALUE
sf_s_bessel_K1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1_scaled-class_method">
  
    .<strong>bessel_K1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of first order \exp(x) K_1(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14000
14001
14002
14003
14004
14005
14006
14007
14008</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14000</span>

static VALUE
sf_s_bessel_K1_scaled(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k1_scaled-class_method">
  
    .<strong>bessel_k1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of first order, \exp(x) k_1(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15721
15722
15723
15724
15725
15726
15727
15728
15729</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15721</span>

static VALUE
sf_s_bessel_k1_scaled(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1_scaled_e-class_method">
  
    .<strong>bessel_K1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of first order \exp(x) K_1(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14043
14044
14045
14046
14047
14048
14049
14050
14051
14052
14053
14054
14055
14056</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14043</span>

static VALUE
sf_s_bessel_K1_scaled_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k1_scaled_e-class_method">
  
    .<strong>bessel_k1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of first order, \exp(x) k_1(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15764
15765
15766
15767
15768
15769
15770
15771
15772
15773
15774
15775
15776
15777</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15764</span>

static VALUE
sf_s_bessel_k1_scaled_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k2_scaled-class_method">
  
    .<strong>bessel_k2_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of second order, \exp(x) k_2(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15810
15811
15812
15813
15814
15815
15816
15817
15818</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15810</span>

static VALUE
sf_s_bessel_k2_scaled(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k2_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k2_scaled_e-class_method">
  
    .<strong>bessel_k2_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of second order, \exp(x) k_2(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15853
15854
15855
15856
15857
15858
15859
15860
15861
15862
15863
15864
15865
15866</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15853</span>

static VALUE
sf_s_bessel_k2_scaled_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k2_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_kl_scaled-class_method">
  
    .<strong>bessel_kl_scaled</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of order l, \exp(x) k_l(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15902
15903
15904
15905
15906
15907
15908
15909
15910
15911
15912
15913</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15902</span>

static VALUE
sf_s_bessel_kl_scaled(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_kl_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_kl_scaled_array-class_method">
  
    .<strong>bessel_kl_scaled_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled irregular modified
spherical Bessel functions \exp(x) k_l(x) for l from
0 to lmax inclusive for $lmax \geq 0$
lmax &gt;= 0 and x&gt;0, storing the results in
the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16014
16015
16016
16017
16018
16019
16020
16021
16022
16023
16024
16025
16026
16027
16028
16029
16030
16031
16032
16033
16034
16035
16036</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16014</span>

static VALUE
sf_s_bessel_kl_scaled_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_kl_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_kl_scaled_e-class_method">
  
    .<strong>bessel_kl_scaled_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of order l, \exp(x) k_l(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15952
15953
15954
15955
15956
15957
15958
15959
15960
15961
15962
15963
15964
15965
15966
15967
15968
15969</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15952</span>

static VALUE
sf_s_bessel_kl_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_kl_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn-class_method">
  
    .<strong>bessel_Kn</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of order n, K_n(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13736
13737
13738
13739
13740
13741
13742
13743
13744
13745
13746
13747</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13736</span>

static VALUE
sf_s_bessel_Kn(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_array-class_method">
  
    .<strong>bessel_Kn_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the irregular modified cylindrical
Bessel functions K_n(x) for n from nmin to
nmax inclusive, storing the results in the array
result_array. The start of the range nmin must be positive
or zero. The domain of the function is x&gt;0. The values are
computed using recurrence relations for efficiency, and therefore
may differ slightly from the exact values.
Conditions: n=nmin,…,nmax
Domain: x &gt; 0.0, nmin&gt;=0, nmax &gt;= nmin
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13853
13854
13855
13856
13857
13858
13859
13860
13861
13862
13863
13864
13865
13866
13867
13868
13869
13870
13871
13872
13873
13874
13875
13876
13877
13878</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13853</span>

static VALUE
sf_s_bessel_Kn_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_e-class_method">
  
    .<strong>bessel_Kn_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of order n, K_n(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13786
13787
13788
13789
13790
13791
13792
13793
13794
13795
13796
13797
13798
13799
13800
13801
13802
13803</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13786</span>

static VALUE
sf_s_bessel_Kn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_scaled-class_method">
  
    .<strong>bessel_Kn_scaled</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of order n, \exp(x) K_n(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14092
14093
14094
14095
14096
14097
14098
14099
14100
14101
14102
14103</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14092</span>

static VALUE
sf_s_bessel_Kn_scaled(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_scaled_array-class_method">
  
    .<strong>bessel_Kn_scaled_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled irregular cylindrical
Bessel functions \exp(x) K_n(x) for n from nmin to
nmax inclusive, storing the results in the array
result_array. The start of the range nmin must be positive
or zero.  The domain of the function is x&gt;0. The values are
computed using recurrence relations for efficiency, and therefore
may differ slightly from the exact values.
Domain: x &gt; 0.0, nmin &gt;=0, nmax &gt;= nmin
Conditions: n=nmin,…,nmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14209
14210
14211
14212
14213
14214
14215
14216
14217
14218
14219
14220
14221
14222
14223
14224
14225
14226
14227
14228
14229
14230
14231
14232
14233
14234</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14209</span>

static VALUE
sf_s_bessel_Kn_scaled_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_scaled_e-class_method">
  
    .<strong>bessel_Kn_scaled_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of order n, \exp(x) K_n(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14142
14143
14144
14145
14146
14147
14148
14149
14150
14151
14152
14153
14154
14155
14156
14157
14158
14159</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14142</span>

static VALUE
sf_s_bessel_Kn_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu-class_method">
  
    .<strong>bessel_Knu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified Bessel function of
fractional order \nu, K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16455
16456
16457
16458
16459
16460
16461
16462
16463</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16455</span>

static VALUE
sf_s_bessel_Knu(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu_e-class_method">
  
    .<strong>bessel_Knu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified Bessel function of
fractional order \nu, K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16502
16503
16504
16505
16506
16507
16508
16509
16510
16511
16512
16513
16514
16515</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16502</span>

static VALUE
sf_s_bessel_Knu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu_scaled-class_method">
  
    .<strong>bessel_Knu_scaled</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified Bessel function of
fractional order \nu, \exp(+|x|) K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16649
16650
16651
16652
16653
16654
16655
16656
16657</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16649</span>

static VALUE
sf_s_bessel_Knu_scaled(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu_scaled, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu_scaled_e-class_method">
  
    .<strong>bessel_Knu_scaled_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified Bessel function of
fractional order \nu, \exp(+|x|) K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16696
16697
16698
16699
16700
16701
16702
16703
16704
16705
16706
16707
16708
16709</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16696</span>

static VALUE
sf_s_bessel_Knu_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_lnKnu-class_method">
  
    .<strong>bessel_lnKnu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the irregular modified Bessel
function of fractional order \nu, \ln(K_\nu(x)) for
x&gt;0, \nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16552
16553
16554
16555
16556
16557
16558
16559
16560</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16552</span>

static VALUE
sf_s_bessel_lnKnu(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_lnKnu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_lnKnu_e-class_method">
  
    .<strong>bessel_lnKnu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the irregular modified Bessel
function of fractional order \nu, \ln(K_\nu(x)) for
x&gt;0, \nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16599
16600
16601
16602
16603
16604
16605
16606
16607
16608
16609
16610
16611
16612</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16599</span>

static VALUE
sf_s_bessel_lnKnu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_lnKnu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y0-class_method">
  
    .<strong>bessel_Y0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of zeroth
order, Y_0(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12509
12510
12511
12512
12513
12514
12515
12516
12517</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12509</span>

static VALUE
sf_s_bessel_Y0(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y0-class_method">
  
    .<strong>bessel_y0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of zeroth
order, y_0(x) = -\cos(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14770
14771
14772
14773
14774
14775
14776
14777
14778</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14770</span>

static VALUE
sf_s_bessel_y0(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y0_e-class_method">
  
    .<strong>bessel_Y0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of zeroth
order, Y_0(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12551
12552
12553
12554
12555
12556
12557
12558
12559
12560
12561
12562
12563
12564</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12551</span>

static VALUE
sf_s_bessel_Y0_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y0_e-class_method">
  
    .<strong>bessel_y0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of zeroth
order, y_0(x) = -\cos(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14812
14813
14814
14815
14816
14817
14818
14819
14820
14821
14822
14823
14824
14825</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14812</span>

static VALUE
sf_s_bessel_y0_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y1-class_method">
  
    .<strong>bessel_Y1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of first
order, Y_1(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12596
12597
12598
12599
12600
12601
12602
12603
12604</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12596</span>

static VALUE
sf_s_bessel_Y1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y1-class_method">
  
    .<strong>bessel_y1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of first
order, y_1(x) = -(\cos(x)/x + \sin(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14857
14858
14859
14860
14861
14862
14863
14864
14865</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14857</span>

static VALUE
sf_s_bessel_y1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y1_e-class_method">
  
    .<strong>bessel_Y1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of first
order, Y_1(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12638
12639
12640
12641
12642
12643
12644
12645
12646
12647
12648
12649
12650
12651</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12638</span>

static VALUE
sf_s_bessel_Y1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y1_e-class_method">
  
    .<strong>bessel_y1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of first
order, y_1(x) = -(\cos(x)/x + \sin(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14899
14900
14901
14902
14903
14904
14905
14906
14907
14908
14909
14910
14911
14912</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14899</span>

static VALUE
sf_s_bessel_y1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y2-class_method">
  
    .<strong>bessel_y2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of second
order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14944
14945
14946
14947
14948
14949
14950
14951
14952</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14944</span>

static VALUE
sf_s_bessel_y2(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y2_e-class_method">
  
    .<strong>bessel_y2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of second
order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14986
14987
14988
14989
14990
14991
14992
14993
14994
14995
14996
14997
14998
14999</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14986</span>

static VALUE
sf_s_bessel_y2_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_yl-class_method">
  
    .<strong>bessel_yl</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of
order l, y_l(x), for $l \geq 0$
l &gt;= 0.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15035
15036
15037
15038
15039
15040
15041
15042
15043
15044
15045
15046</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15035</span>

static VALUE
sf_s_bessel_yl(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_yl, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_yl_array-class_method">
  
    .<strong>bessel_yl_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the irregular spherical Bessel
functions y_l(x) for l from 0 to lmax
inclusive  for $lmax \geq 0$
lmax &gt;= 0, storing the results in the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15146
15147
15148
15149
15150
15151
15152
15153
15154
15155
15156
15157
15158
15159
15160
15161
15162
15163
15164
15165
15166
15167
15168</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15146</span>

static VALUE
sf_s_bessel_yl_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_yl_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_yl_e-class_method">
  
    .<strong>bessel_yl_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of
order l, y_l(x), for $l \geq 0$
l &gt;= 0.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15085
15086
15087
15088
15089
15090
15091
15092
15093
15094
15095
15096
15097
15098
15099
15100
15101
15102</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15085</span>

static VALUE
sf_s_bessel_yl_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_yl_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Yn-class_method">
  
    .<strong>bessel_Yn</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
order n, Y_n(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12686
12687
12688
12689
12690
12691
12692
12693
12694
12695
12696
12697</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12686</span>

static VALUE
sf_s_bessel_Yn(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Yn, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Yn_array-class_method">
  
    .<strong>bessel_Yn_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the irregular cylindrical Bessel
functions Y_n(x) for n from nmin to nmax
inclusive, storing the results in the array result_array.  The
domain of the function is x&gt;0.  The values are computed using
recurrence relations for efficiency, and therefore may differ slightly
from the exact values.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12799
12800
12801
12802
12803
12804
12805
12806
12807
12808
12809
12810
12811
12812
12813
12814
12815
12816
12817
12818
12819
12820
12821
12822
12823
12824</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12799</span>

static VALUE
sf_s_bessel_Yn_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Yn_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Yn_e-class_method">
  
    .<strong>bessel_Yn_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
order n, Y_n(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12735
12736
12737
12738
12739
12740
12741
12742
12743
12744
12745
12746
12747
12748
12749
12750
12751
12752</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12735</span>

static VALUE
sf_s_bessel_Yn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Yn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Ynu-class_method">
  
    .<strong>bessel_Ynu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
fractional order \nu, Y_\nu(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16164
16165
16166
16167
16168
16169
16170
16171
16172</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16164</span>

static VALUE
sf_s_bessel_Ynu(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Ynu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Ynu_e-class_method">
  
    .<strong>bessel_Ynu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
fractional order \nu, Y_\nu(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16209
16210
16211
16212
16213
16214
16215
16216
16217
16218
16219
16220
16221
16222</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16209</span>

static VALUE
sf_s_bessel_Ynu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Ynu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J0-class_method">
  
    .<strong>bessel_zero_J0</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_0(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16742
16743
16744
16745
16746
16747
16748
16749
16750</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16742</span>

static VALUE
sf_s_bessel_zero_J0(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J0_e-class_method">
  
    .<strong>bessel_zero_J0_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_0(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16784
16785
16786
16787
16788
16789
16790
16791
16792
16793
16794
16795
16796
16797</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16784</span>

static VALUE
sf_s_bessel_zero_J0_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J1-class_method">
  
    .<strong>bessel_zero_J1</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_1(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16830
16831
16832
16833
16834
16835
16836
16837
16838</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16830</span>

static VALUE
sf_s_bessel_zero_J1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J1_e-class_method">
  
    .<strong>bessel_zero_J1_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_1(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16872
16873
16874
16875
16876
16877
16878
16879
16880
16881
16882
16883
16884
16885</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16872</span>

static VALUE
sf_s_bessel_zero_J1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_Jnu-class_method">
  
    .<strong>bessel_zero_Jnu</strong>(nu, s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_\nu(x).  The current implementation does not
support negative values of nu.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16922
16923
16924
16925
16926
16927
16928
16929
16930</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16922</span>

static VALUE
sf_s_bessel_zero_Jnu(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cUInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_Jnu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_Jnu_e-class_method">
  
    .<strong>bessel_zero_Jnu_e</strong>(nu, s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_\nu(x).  The current implementation does not
support negative values of nu.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16968
16969
16970
16971
16972
16973
16974
16975
16976
16977
16978
16979
16980
16981</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16968</span>

static VALUE
sf_s_bessel_zero_Jnu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_Jnu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta-class_method">
  
    .<strong>beta</strong>(a, b)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Beta Function, B(a,b) =
\Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not
being negative integers.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3244
3245
3246
3247
3248
3249
3250
3251
3252</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3244</span>

static VALUE
sf_s_beta(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_beta, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta_e-class_method">
  
    .<strong>beta_e</strong>(a, b)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Beta Function, B(a,b) =
\Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not
being negative integers.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3290
3291
3292
3293
3294
3295
3296
3297
3298
3299
3300
3301
3302
3303</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3290</span>

static VALUE
sf_s_beta_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_beta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta_inc-class_method">
  
    .<strong>beta_inc</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Beta function
I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$
B_x(a,b) = \int_0^x t^[a-1] (1-t)^[b-1] dt
for $0 \le x \le 1$
0 &lt;= x &lt;= 1.   For a &gt; 0, b &gt; 0 the value is computed using
a continued fraction expansion.  For all other values it is computed using
the relation $I_x(a,b,x) = (1/a) x^a {}_2F_1(a,1-b,a+1,x)/B(a,b)$
I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3441
3442
3443
3444
3445
3446
3447
3448
3449</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3441</span>

static VALUE
sf_s_beta_inc(VALUE mod, VALUE v0, VALUE v1, VALUE v2)
{
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_beta_inc, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta_inc_e-class_method">
  
    .<strong>beta_inc_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Beta function
I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$
B_x(a,b) = \int_0^x t^[a-1] (1-t)^[b-1] dt
for $0 \le x \le 1$
0 &lt;= x &lt;= 1.   For a &gt; 0, b &gt; 0 the value is computed using
a continued fraction expansion.  For all other values it is computed using
the relation $I_x(a,b,x) = (1/a) x^a {}_2F_1(a,1-b,a+1,x)/B(a,b)$
I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3494
3495
3496
3497
3498
3499
3500
3501
3502
3503
3504
3505
3506
3507</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3494</span>

static VALUE
sf_s_beta_inc_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_beta_inc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Chi-class_method">
  
    .<strong>Chi</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$
Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] ,
where \gamma_E is the Euler constant (available as the macro M_EULER).
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5815
5816
5817
5818
5819
5820
5821
5822
5823</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5815</span>

static VALUE
sf_s_Chi(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Chi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Chi_e-class_method">
  
    .<strong>Chi_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$
Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] ,
where \gamma_E is the Euler constant (available as the macro M_EULER).
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5859
5860
5861
5862
5863
5864
5865
5866
5867
5868
5869
5870
5871
5872</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5859</span>

static VALUE
sf_s_Chi_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Chi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="choose-class_method">
  
    .<strong>choose</strong>(n, m)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the combinatorial factor n choose m
= n!/(m!(n-m)!)
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2299
2300
2301
2302
2303
2304
2305
2306
2307
2308
2309
2310
2311
2312</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2299</span>

static VALUE
sf_s_choose(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_choose,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="choose_e-class_method">
  
    .<strong>choose_e</strong>(n, m)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the combinatorial factor n choose m
= n!/(m!(n-m)!)
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2349
2350
2351
2352
2353
2354
2355
2356
2357
2358
2359
2360
2361
2362</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2349</span>

static VALUE
sf_s_choose_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_choose_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Ci-class_method">
  
    .<strong>Ci</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$
Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6081
6082
6083
6084
6085
6086
6087
6088
6089</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6081</span>

static VALUE
sf_s_Ci(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Ci, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Ci_e-class_method">
  
    .<strong>Ci_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$
Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6124
6125
6126
6127
6128
6129
6130
6131
6132
6133
6134
6135
6136
6137</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6124</span>

static VALUE
sf_s_Ci_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Ci_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="clausen-class_method">
  
    .<strong>clausen</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Clausen integral Cl_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23732
23733
23734
23735
23736
23737
23738
23739
23740</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23732</span>

static VALUE
sf_s_clausen(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_clausen, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="clausen_e-class_method">
  
    .<strong>clausen_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Clausen integral Cl_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23772
23773
23774
23775
23776
23777
23778
23779
23780
23781
23782
23783
23784
23785</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23772</span>

static VALUE
sf_s_clausen_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_clausen_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_cos_e-class_method">
  
    .<strong>complex_cos_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the complex cosine, \cos(z_r + i z_i) storing
the real and imaginary parts in czr, czi.
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [czr.val, czr.err, czi.val, czi.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


877
878
879
880
881
882
883
884
885
886
887
888
889
890</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 877</span>

static VALUE
sf_s_complex_cos_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_cos_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_dilog_e-class_method">
  
    .<strong>complex_dilog_e</strong>(r, theta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the full complex-valued dilogarithm for the
complex argument z = r \exp(i \theta). The real and imaginary
parts of the result are returned in result_re, result_im.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_re.val, result_re.err, result_im.val, result_im.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12118
12119
12120
12121
12122
12123
12124
12125
12126
12127
12128
12129
12130
12131</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12118</span>

static VALUE
sf_s_complex_dilog_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_dilog_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_log_e-class_method">
  
    .<strong>complex_log_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the complex logarithm of z = z_r + i
z_i. The results are returned as lnr, theta such that
\exp(lnr + i \theta) = z_r + i z_i, where \theta lies in
the range [-\pi,\pi].
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [lnr.val, lnr.err, theta.val, theta.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


243
244
245
246
247
248
249
250
251
252
253
254
255
256</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 243</span>

static VALUE
sf_s_complex_log_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_log_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_logsin_e-class_method">
  
    .<strong>complex_logsin_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the logarithm of the complex sine,
\log(\sin(z_r + i z_i)) storing the real and imaginary parts in
lszr, lszi.
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [lszr.val, lszr.err, lszi.val, lszi.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


931
932
933
934
935
936
937
938
939
940
941
942
943
944</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 931</span>

static VALUE
sf_s_complex_logsin_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_logsin_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_sin_e-class_method">
  
    .<strong>complex_sin_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the complex sine, \sin(z_r + i z_i) storing
the real and imaginary parts in szr, szi.
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [szr.val, szr.err, szi.val, szi.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


824
825
826
827
828
829
830
831
832
833
834
835
836
837</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 824</span>

static VALUE
sf_s_complex_sin_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_sin_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_0-class_method">
  
    .<strong>conicalP_0</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^0<em>+ i \lambda(x)$
P^0</em><a href="x">-1/2 + i \lambda</a>
for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21691
21692
21693
21694
21695
21696
21697
21698
21699</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21691</span>

static VALUE
sf_s_conicalP_0(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_0, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_0_e-class_method">
  
    .<strong>conicalP_0_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^0<em>+ i \lambda(x)$
P^0</em><a href="x">-1/2 + i \lambda</a>
for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21738
21739
21740
21741
21742
21743
21744
21745
21746
21747
21748
21749
21750
21751</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21738</span>

static VALUE
sf_s_conicalP_0_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_1-class_method">
  
    .<strong>conicalP_1</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^1<em>+ i \lambda(x)$
P^1</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21787
21788
21789
21790
21791
21792
21793
21794
21795</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21787</span>

static VALUE
sf_s_conicalP_1(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_1_e-class_method">
  
    .<strong>conicalP_1_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^1<em>+ i \lambda(x)$
P^1</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21833
21834
21835
21836
21837
21838
21839
21840
21841
21842
21843
21844
21845
21846</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21833</span>

static VALUE
sf_s_conicalP_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_cyl_reg-class_method">
  
    .<strong>conicalP_cyl_reg</strong>(m, lambda, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Cylindrical Conical Function
$P^-m<em>+ i \lambda(x)$
P^[-m]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1, $m \ge -1$
m &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22003
22004
22005
22006
22007
22008
22009
22010
22011
22012
22013
22014
22015
22016
22017
22018
22019
22020</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22003</span>

static VALUE
sf_s_conicalP_cyl_reg(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_cyl_reg,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //m
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_cyl_reg_e-class_method">
  
    .<strong>conicalP_cyl_reg_e</strong>(m, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Cylindrical Conical Function
$P^-m<em>+ i \lambda(x)$
P^[-m]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1, $m \ge -1$
m &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22063
22064
22065
22066
22067
22068
22069
22070
22071
22072
22073
22074
22075
22076
22077
22078
22079
22080</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22063</span>

static VALUE
sf_s_conicalP_cyl_reg_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_cyl_reg_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //m
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_half-class_method">
  
    .<strong>conicalP_half</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular Spherical Conical Function
$P^1/2<em>+ i \lambda(x)$
P^[1/2]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21500
21501
21502
21503
21504
21505
21506
21507
21508</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21500</span>

static VALUE
sf_s_conicalP_half(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_half, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_half_e-class_method">
  
    .<strong>conicalP_half_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular Spherical Conical Function
$P^1/2<em>+ i \lambda(x)$
P^[1/2]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21546
21547
21548
21549
21550
21551
21552
21553
21554
21555
21556
21557
21558
21559</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21546</span>

static VALUE
sf_s_conicalP_half_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_half_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_mhalf-class_method">
  
    .<strong>conicalP_mhalf</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular Spherical Conical Function
$P^-1/2<em>+ i \lambda(x)$
P^[-1/2]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21595
21596
21597
21598
21599
21600
21601
21602
21603</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21595</span>

static VALUE
sf_s_conicalP_mhalf(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_mhalf, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_mhalf_e-class_method">
  
    .<strong>conicalP_mhalf_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular Spherical Conical Function
$P^-1/2<em>+ i \lambda(x)$
P^[-1/2]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21641
21642
21643
21644
21645
21646
21647
21648
21649
21650
21651
21652
21653
21654</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21641</span>

static VALUE
sf_s_conicalP_mhalf_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_mhalf_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_sph_reg-class_method">
  
    .<strong>conicalP_sph_reg</strong>(l, lambda, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Spherical Conical Function
$P^-1/2-l<em>+ i \lambda(x)$
P^[-1/2-l]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1, $l \ge -1$
l &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21886
21887
21888
21889
21890
21891
21892
21893
21894
21895
21896
21897
21898
21899
21900
21901
21902
21903</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21886</span>

static VALUE
sf_s_conicalP_sph_reg(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_sph_reg,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_sph_reg_e-class_method">
  
    .<strong>conicalP_sph_reg_e</strong>(l, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Spherical Conical Function
$P^-1/2-l<em>+ i \lambda(x)$
P^[-1/2-l]</em><a href="x">-1/2 + i \lambda</a> for x &gt; -1, $l \ge -1$
l &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21946
21947
21948
21949
21950
21951
21952
21953
21954
21955
21956
21957
21958
21959
21960
21961
21962
21963</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21946</span>

static VALUE
sf_s_conicalP_sph_reg_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_sph_reg_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="cos-class_method">
  
    .<strong>cos</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the cosine function \cos(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


550
551
552
553
554
555
556
557
558</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 550</span>

static VALUE
sf_s_cos(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_cos, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="cos_e-class_method">
  
    .<strong>cos_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the cosine function \cos(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


591
592
593
594
595
596
597
598
599
600
601
602
603
604</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 591</span>

static VALUE
sf_s_cos_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_cos_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="cos_err_e-class_method">
  
    .<strong>cos_err_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the cosine of an angle x with an associated
absolute error dx,
$\cos(x \pm dx)$
\cos(x \pm dx).  Note that this function is provided in the error-handling form only since
its purpose is to compute the propagated error.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1405
1406
1407
1408
1409
1410
1411
1412
1413
1414
1415
1416
1417
1418</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1405</span>

static VALUE
sf_s_cos_err_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_cos_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_CL_array-class_method">
  
    .<strong>coulomb_CL_array</strong>(Lmin, kmax, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function normalization constant
C_L(\eta) for L = Lmin \dots Lmin + kmax, Lmin &gt; -1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>Lmin</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [cl[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17682
17683
17684
17685
17686
17687
17688
17689
17690
17691
17692
17693
17694
17695
17696
17697
17698
17699
17700
17701
17702
17703
17704</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17682</span>

static VALUE
sf_s_coulomb_CL_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_CL_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,2,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
    return na_ndloop3(&amp;ndf,opt,2,v0,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_CL_e-class_method">
  
    .<strong>coulomb_CL_e</strong>(L, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function normalization constant
C_L(\eta) for L &gt; -1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17629
17630
17631
17632
17633
17634
17635
17636
17637
17638
17639
17640
17641
17642</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17629</span>

static VALUE
sf_s_coulomb_CL_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_CL_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_F_array-class_method">
  
    .<strong>coulomb_wave_F_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function F_L(\eta,x) for
L = Lmin \dots Lmin + kmax, storing the results in fc_array.
In the case of overflow the exponent is stored in F_exponent.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], F_exponent, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17340
17341
17342
17343
17344
17345
17346
17347
17348
17349
17350
17351
17352
17353
17354
17355
17356
17357
17358
17359
17360
17361
17362</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17340</span>

static VALUE
sf_s_coulomb_wave_F_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_F_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_FG_array-class_method">
  
    .<strong>coulomb_wave_FG_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the functions F_L(\eta,x),
G_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the
results in fc_array and gc_array.  In the case of overflow the
exponents are stored in F_exponent and G_exponent.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], gc_array[], F_exponent, G_exponent, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17416
17417
17418
17419
17420
17421
17422
17423
17424
17425
17426
17427
17428
17429
17430
17431
17432
17433
17434
17435
17436
17437
17438</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17416</span>

static VALUE
sf_s_coulomb_wave_FG_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,1,shape},{cDF,1,shape},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_FG_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,5,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_FG_e-class_method">
  
    .<strong>coulomb_wave_FG_e</strong>(eta, x, L_F, k)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave functions F_L(\eta,x),
$G_L-k(\eta,x)$
G_<a href="\eta,x">L-k</a> and their derivatives
F’<em>L(\eta,x),
$G’</em>L-k(\eta,x)$
G’_<a href="\eta,x">L-k</a>
with respect to x.  The parameters are restricted to L,
L-k &gt; -1/2, x &gt; 0 and integer k.  Note that L
itself is not restricted to being an integer. The results are stored in
the parameters F, G for the function values and Fp,
Gp for the derivative values.  If an overflow occurs,
GSL_EOVRFLW is returned and scaling exponents are stored in
the modifiable parameters exp_F, exp_G.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>L_F</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [F.val, F.err, Fp.val, Fp.err, G.val, G.err, Gp.val, Gp.err, exp_F, exp_G, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17276
17277
17278
17279
17280
17281
17282
17283
17284
17285
17286
17287
17288
17289
17290
17291
17292
17293</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17276</span>

static VALUE
sf_s_coulomb_wave_FG_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c3;
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[11] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_FG_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,11,ain,aout};
    
    void *opt;
    c3 = NUM2INT(v3); opt = &amp;c3; //k
    
    
    return na_ndloop3(&amp;ndf,opt,3,v0,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_FGp_array-class_method">
  
    .<strong>coulomb_wave_FGp_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the functions F_L(\eta,x),
G_L(\eta,x) and their derivatives F’_L(\eta,x),
G’_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the
results in fc_array, gc_array, fcp_array and gcp_array.
In the case of overflow the exponents are stored in F_exponent
and G_exponent.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], fcp_array[], gc_array[], gcp_array[], F_exponent, G_exponent, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17500
17501
17502
17503
17504
17505
17506
17507
17508
17509
17510
17511
17512
17513
17514
17515
17516
17517
17518
17519
17520
17521
17522</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17500</span>

static VALUE
sf_s_coulomb_wave_FGp_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[7] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_FGp_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,7,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_sphF_array-class_method">
  
    .<strong>coulomb_wave_sphF_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function divided by the argument
F_L(\eta, x)/x for L = Lmin \dots Lmin + kmax, storing the
results in fc_array.  In the case of overflow the exponent is
stored in F_exponent. This function reduces to spherical Bessel
functions in the limit \eta \to 0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], F_exponent[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17571
17572
17573
17574
17575
17576
17577
17578
17579
17580
17581
17582
17583
17584
17585
17586
17587
17588
17589
17590
17591
17592
17593</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17571</span>

static VALUE
sf_s_coulomb_wave_sphF_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_sphF_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_3j-class_method">
  
    .<strong>coupling_3j</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; <tt>Float</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 3-j coefficient,</p>

<p>(ja jb jc
ma mb mc)</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ma</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7193
7194
7195
7196
7197
7198
7199
7200
7201
7202
7203
7204
7205
7206
7207
7208
7209
7210
7211
7212
7213
7214
7215</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7193</span>

static VALUE
sf_s_coupling_3j(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    double c6;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
    c6 = gsl_sf_coupling_3j(c0,c1,c2,c3,c4,c5);
    
    return DBL2NUM(c6);
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_3j_e-class_method">
  
    .<strong>coupling_3j_e</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 3-j coefficient,</p>

<p>(ja jb jc
ma mb mc)</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ma</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7239
7240
7241
7242
7243
7244
7245
7246
7247
7248
7249
7250
7251
7252
7253
7254
7255
7256
7257
7258
7259
7260
7261
7262
7263
7264
7265
7266
7267
7268
7269</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7239</span>

static VALUE
sf_s_coupling_3j_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    gsl_sf_result c6;
    int c7;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
    c7 = gsl_sf_coupling_3j_e(c0,c1,c2,c3,c4,c5,&amp;c6);
    
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c6.val));
        rb_ary_push(va,DBL2NUM(c6.err));
        rb_ary_push(va,INT2NUM(c7));
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_6j-class_method">
  
    .<strong>coupling_6j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; <tt>Float</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 6-j coefficient,</p>

<p>[ja jb jc
jd je jf]</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7293
7294
7295
7296
7297
7298
7299
7300
7301
7302
7303
7304
7305
7306
7307
7308
7309
7310
7311
7312
7313
7314
7315</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7293</span>

static VALUE
sf_s_coupling_6j(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    double c6;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
    c6 = gsl_sf_coupling_6j(c0,c1,c2,c3,c4,c5);
    
    return DBL2NUM(c6);
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_6j_e-class_method">
  
    .<strong>coupling_6j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 6-j coefficient,</p>

<p>[ja jb jc
jd je jf]</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7339
7340
7341
7342
7343
7344
7345
7346
7347
7348
7349
7350
7351
7352
7353
7354
7355
7356
7357
7358
7359
7360
7361
7362
7363
7364
7365
7366
7367
7368
7369</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7339</span>

static VALUE
sf_s_coupling_6j_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    gsl_sf_result c6;
    int c7;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
    c7 = gsl_sf_coupling_6j_e(c0,c1,c2,c3,c4,c5,&amp;c6);
    
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c6.val));
        rb_ary_push(va,DBL2NUM(c6.err));
        rb_ary_push(va,INT2NUM(c7));
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_9j-class_method">
  
    .<strong>coupling_9j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; <tt>Float</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 9-j coefficient,</p>

<p>[ja jb jc
jd je jf
jg jh ji]</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jg</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jh</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ji</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7397
7398
7399
7400
7401
7402
7403
7404
7405
7406
7407
7408
7409
7410
7411
7412
7413
7414
7415
7416
7417
7418
7419
7420
7421
7422
7423
7424
7425</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7397</span>

static VALUE
sf_s_coupling_9j(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5,VALUE v6,VALUE v7,VALUE v8)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    int c6;
    int c7;
    int c8;
    double c9;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
    c6 = NUM2INT(v6);
    c7 = NUM2INT(v7);
    c8 = NUM2INT(v8);
    c9 = gsl_sf_coupling_9j(c0,c1,c2,c3,c4,c5,c6,c7,c8);
    
    return DBL2NUM(c9);
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_9j_e-class_method">
  
    .<strong>coupling_9j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 9-j coefficient,</p>

<p>[ja jb jc
jd je jf
jg jh ji]</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jg</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jh</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ji</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7453
7454
7455
7456
7457
7458
7459
7460
7461
7462
7463
7464
7465
7466
7467
7468
7469
7470
7471
7472
7473
7474
7475
7476
7477
7478
7479
7480
7481
7482
7483
7484
7485
7486
7487
7488
7489</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7453</span>

static VALUE
sf_s_coupling_9j_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5,VALUE v6,VALUE v7,VALUE v8)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    int c6;
    int c7;
    int c8;
    gsl_sf_result c9;
    int c10;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
    c6 = NUM2INT(v6);
    c7 = NUM2INT(v7);
    c8 = NUM2INT(v8);
    c10 = gsl_sf_coupling_9j_e(c0,c1,c2,c3,c4,c5,c6,c7,c8,&amp;c9);
    
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c9.val));
        rb_ary_push(va,DBL2NUM(c9.err));
        rb_ary_push(va,INT2NUM(c10));
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dawson-class_method">
  
    .<strong>dawson</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the value of Dawson’s integral for x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10083
10084
10085
10086
10087
10088
10089
10090
10091</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10083</span>

static VALUE
sf_s_dawson(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_dawson, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dawson_e-class_method">
  
    .<strong>dawson_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the value of Dawson’s integral for x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10124
10125
10126
10127
10128
10129
10130
10131
10132
10133
10134
10135
10136
10137</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10124</span>

static VALUE
sf_s_dawson_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_dawson_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_1-class_method">
  
    .<strong>debye_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first-order Debye function
D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8049
8050
8051
8052
8053
8054
8055
8056
8057</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8049</span>

static VALUE
sf_s_debye_1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_1_e-class_method">
  
    .<strong>debye_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first-order Debye function
D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8091
8092
8093
8094
8095
8096
8097
8098
8099
8100
8101
8102
8103
8104</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8091</span>

static VALUE
sf_s_debye_1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_2-class_method">
  
    .<strong>debye_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order Debye function
D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8136
8137
8138
8139
8140
8141
8142
8143
8144</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8136</span>

static VALUE
sf_s_debye_2(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_2_e-class_method">
  
    .<strong>debye_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order Debye function
D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8178
8179
8180
8181
8182
8183
8184
8185
8186
8187
8188
8189
8190
8191</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8178</span>

static VALUE
sf_s_debye_2_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_3-class_method">
  
    .<strong>debye_3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order Debye function
D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8223
8224
8225
8226
8227
8228
8229
8230
8231</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8223</span>

static VALUE
sf_s_debye_3(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_3_e-class_method">
  
    .<strong>debye_3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order Debye function
D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8265
8266
8267
8268
8269
8270
8271
8272
8273
8274
8275
8276
8277
8278</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8265</span>

static VALUE
sf_s_debye_3_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_4-class_method">
  
    .<strong>debye_4</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fourth-order Debye function
D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8310
8311
8312
8313
8314
8315
8316
8317
8318</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8310</span>

static VALUE
sf_s_debye_4(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_4, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_4_e-class_method">
  
    .<strong>debye_4_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fourth-order Debye function
D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8352
8353
8354
8355
8356
8357
8358
8359
8360
8361
8362
8363
8364
8365</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8352</span>

static VALUE
sf_s_debye_4_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_4_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_5-class_method">
  
    .<strong>debye_5</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fifth-order Debye function
D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8397
8398
8399
8400
8401
8402
8403
8404
8405</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8397</span>

static VALUE
sf_s_debye_5(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_5, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_5_e-class_method">
  
    .<strong>debye_5_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fifth-order Debye function
D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8439
8440
8441
8442
8443
8444
8445
8446
8447
8448
8449
8450
8451
8452</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8439</span>

static VALUE
sf_s_debye_5_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_5_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_6-class_method">
  
    .<strong>debye_6</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sixth-order Debye function
D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8484
8485
8486
8487
8488
8489
8490
8491
8492</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8484</span>

static VALUE
sf_s_debye_6(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_6, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_6_e-class_method">
  
    .<strong>debye_6_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sixth-order Debye function
D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8526
8527
8528
8529
8530
8531
8532
8533
8534
8535
8536
8537
8538
8539</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8526</span>

static VALUE
sf_s_debye_6_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_6_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dilog-class_method">
  
    .<strong>dilog</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the dilogarithm for a real argument. In Lewin’s
notation this is Li_2(x), the real part of the dilogarithm of a
real x.  It is defined by the integral representation
Li_2(x) = - \Re \int_0^x ds \log(1-s) / s.
Note that \Im(Li_2(x)) = 0 for $x \le 1$
x &lt;= 1, and -\pi\log(x) for x &gt; 1.</p>

<p>Note that Abramowitz &amp; Stegun refer to the Spence integral
S(x)=Li_2(1-x) as the dilogarithm rather than Li_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12017
12018
12019
12020
12021
12022
12023
12024
12025</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12017</span>

static VALUE
sf_s_dilog(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_dilog, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dilog_e-class_method">
  
    .<strong>dilog_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the dilogarithm for a real argument. In Lewin’s
notation this is Li_2(x), the real part of the dilogarithm of a
real x.  It is defined by the integral representation
Li_2(x) = - \Re \int_0^x ds \log(1-s) / s.
Note that \Im(Li_2(x)) = 0 for $x \le 1$
x &lt;= 1, and -\pi\log(x) for x &gt; 1.</p>

<p>Note that Abramowitz &amp; Stegun refer to the Spence integral
S(x)=Li_2(1-x) as the dilogarithm rather than Li_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12065
12066
12067
12068
12069
12070
12071
12072
12073
12074
12075
12076
12077
12078</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12065</span>

static VALUE
sf_s_dilog_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_dilog_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="doublefact-class_method">
  
    .<strong>doublefact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.
The maximum value of n such that n!! is not
considered an overflow is given by the macro GSL_SF_DOUBLEFACT_NMAX
and is 297.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2028
2029
2030
2031
2032
2033
2034
2035
2036</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2028</span>

static VALUE
sf_s_doublefact(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_doublefact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="doublefact_e-class_method">
  
    .<strong>doublefact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.
The maximum value of n such that n!! is not
considered an overflow is given by the macro GSL_SF_DOUBLEFACT_NMAX
and is 297.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2072
2073
2074
2075
2076
2077
2078
2079
2080
2081
2082
2083
2084
2085</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2072</span>

static VALUE
sf_s_doublefact_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_doublefact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_D-class_method">
  
    .<strong>ellint_D</strong>(phi, k, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the incomplete elliptic integral
D(\phi,k) which is defined through the Carlson form RD(x,y,z)
by the following relation,</p>

<p>D(\phi,k) = (1/3)(\sin(\phi))^3 RD (1-\sin^2(\phi), 1-k^2 \sin^2(\phi), 1).</p>

<p>Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4669
4670
4671
4672
4673
4674
4675
4676
4677
4678
4679
4680
4681
4682
4683
4684
4685
4686
4687
4688
4689
4690
4691
4692
4693
4694</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4669</span>

static VALUE
sf_s_ellint_D(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_D,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_D_e-class_method">
  
    .<strong>ellint_D_e</strong>(phi, k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the incomplete elliptic integral
D(\phi,k) which is defined through the Carlson form RD(x,y,z)
by the following relation,</p>

<p>D(\phi,k) = (1/3)(\sin(\phi))^3 RD (1-\sin^2(\phi), 1-k^2 \sin^2(\phi), 1).</p>

<p>Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4739
4740
4741
4742
4743
4744
4745
4746
4747
4748
4749
4750
4751
4752
4753
4754
4755
4756
4757
4758
4759
4760
4761
4762
4763
4764</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4739</span>

static VALUE
sf_s_ellint_D_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_D_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_E-class_method">
  
    .<strong>ellint_E</strong>(phi, k, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral E(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4393
4394
4395
4396
4397
4398
4399
4400
4401
4402
4403
4404
4405
4406
4407
4408
4409
4410
4411
4412
4413
4414
4415
4416
4417
4418</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4393</span>

static VALUE
sf_s_ellint_E(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_E,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_E_e-class_method">
  
    .<strong>ellint_E_e</strong>(phi, k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral E(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4461
4462
4463
4464
4465
4466
4467
4468
4469
4470
4471
4472
4473
4474
4475
4476
4477
4478
4479
4480
4481
4482
4483
4484
4485
4486</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4461</span>

static VALUE
sf_s_ellint_E_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_E_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Ecomp-class_method">
  
    .<strong>ellint_Ecomp</strong>(k[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral E(k) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4004
4005
4006
4007
4008
4009
4010
4011
4012
4013
4014
4015
4016
4017
4018
4019
4020</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4004</span>

static VALUE
sf_s_ellint_Ecomp(int argc, VALUE *v, VALUE mod)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Ecomp, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Ecomp_e-class_method">
  
    .<strong>ellint_Ecomp_e</strong>(k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral E(k) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4060
4061
4062
4063
4064
4065
4066
4067
4068
4069
4070
4071
4072
4073
4074
4075
4076
4077
4078
4079
4080
4081
4082
4083
4084
4085</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4060</span>

static VALUE
sf_s_ellint_Ecomp_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Ecomp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_F-class_method">
  
    .<strong>ellint_F</strong>(phi, k, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral F(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4260
4261
4262
4263
4264
4265
4266
4267
4268
4269
4270
4271
4272
4273
4274
4275
4276
4277
4278
4279
4280
4281
4282
4283
4284
4285</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4260</span>

static VALUE
sf_s_ellint_F(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_F,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_F_e-class_method">
  
    .<strong>ellint_F_e</strong>(phi, k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral F(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4328
4329
4330
4331
4332
4333
4334
4335
4336
4337
4338
4339
4340
4341
4342
4343
4344
4345
4346
4347
4348
4349
4350
4351
4352
4353</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4328</span>

static VALUE
sf_s_ellint_F_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_F_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Kcomp-class_method">
  
    .<strong>ellint_Kcomp</strong>(k[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral K(k) to
the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3885
3886
3887
3888
3889
3890
3891
3892
3893
3894
3895
3896
3897
3898
3899
3900
3901</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3885</span>

static VALUE
sf_s_ellint_Kcomp(int argc, VALUE *v, VALUE mod)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Kcomp, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Kcomp_e-class_method">
  
    .<strong>ellint_Kcomp_e</strong>(k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral K(k) to
the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3941
3942
3943
3944
3945
3946
3947
3948
3949
3950
3951
3952
3953
3954
3955
3956
3957
3958
3959
3960
3961
3962
3963
3964
3965
3966</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3941</span>

static VALUE
sf_s_ellint_Kcomp_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Kcomp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_P-class_method">
  
    .<strong>ellint_P</strong>(phi, k, n, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4530
4531
4532
4533
4534
4535
4536
4537
4538
4539
4540
4541
4542
4543
4544
4545
4546
4547
4548
4549
4550
4551
4552
4553
4554
4555</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4530</span>

static VALUE
sf_s_ellint_P(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_P,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,1,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_P_e-class_method">
  
    .<strong>ellint_P_e</strong>(phi, k, n, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4602
4603
4604
4605
4606
4607
4608
4609
4610
4611
4612
4613
4614
4615
4616
4617
4618
4619
4620
4621
4622
4623
4624
4625
4626
4627</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4602</span>

static VALUE
sf_s_ellint_P_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_P_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Pcomp-class_method">
  
    .<strong>ellint_Pcomp</strong>(k, n, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral \Pi(k,n) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4126
4127
4128
4129
4130
4131
4132
4133
4134
4135
4136
4137
4138
4139
4140
4141
4142
4143
4144
4145
4146
4147
4148
4149
4150
4151</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4126</span>

static VALUE
sf_s_ellint_Pcomp(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Pcomp,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Pcomp_e-class_method">
  
    .<strong>ellint_Pcomp_e</strong>(k, n, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral \Pi(k,n) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4195
4196
4197
4198
4199
4200
4201
4202
4203
4204
4205
4206
4207
4208
4209
4210
4211
4212
4213
4214
4215
4216
4217
4218
4219
4220</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4195</span>

static VALUE
sf_s_ellint_Pcomp_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Pcomp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RC-class_method">
  
    .<strong>ellint_RC</strong>(x, y, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RC(x,y)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4802
4803
4804
4805
4806
4807
4808
4809
4810
4811
4812
4813
4814
4815
4816
4817
4818
4819
4820
4821
4822
4823
4824
4825
4826
4827</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4802</span>

static VALUE
sf_s_ellint_RC(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RC,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RC_e-class_method">
  
    .<strong>ellint_RC_e</strong>(x, y, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RC(x,y)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4868
4869
4870
4871
4872
4873
4874
4875
4876
4877
4878
4879
4880
4881
4882
4883
4884
4885
4886
4887
4888
4889
4890
4891
4892
4893</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4868</span>

static VALUE
sf_s_ellint_RC_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RC_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RD-class_method">
  
    .<strong>ellint_RD</strong>(x, y, z, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RD(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4934
4935
4936
4937
4938
4939
4940
4941
4942
4943
4944
4945
4946
4947
4948
4949
4950
4951
4952
4953
4954
4955
4956
4957
4958
4959</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4934</span>

static VALUE
sf_s_ellint_RD(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RD,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,1,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RD_e-class_method">
  
    .<strong>ellint_RD_e</strong>(x, y, z, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RD(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5003
5004
5005
5006
5007
5008
5009
5010
5011
5012
5013
5014
5015
5016
5017
5018
5019
5020
5021
5022
5023
5024
5025
5026
5027
5028</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5003</span>

static VALUE
sf_s_ellint_RD_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RD_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RF-class_method">
  
    .<strong>ellint_RF</strong>(x, y, z, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RF(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5069
5070
5071
5072
5073
5074
5075
5076
5077
5078
5079
5080
5081
5082
5083
5084
5085
5086
5087
5088
5089
5090
5091
5092
5093
5094</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5069</span>

static VALUE
sf_s_ellint_RF(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RF,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,1,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RF_e-class_method">
  
    .<strong>ellint_RF_e</strong>(x, y, z, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RF(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5138
5139
5140
5141
5142
5143
5144
5145
5146
5147
5148
5149
5150
5151
5152
5153
5154
5155
5156
5157
5158
5159
5160
5161
5162
5163</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5138</span>

static VALUE
sf_s_ellint_RF_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RF_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RJ-class_method">
  
    .<strong>ellint_RJ</strong>(x, y, z, p, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RJ(x,y,z,p)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>p</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5207
5208
5209
5210
5211
5212
5213
5214
5215
5216
5217
5218
5219
5220
5221
5222
5223
5224
5225
5226
5227
5228
5229
5230
5231
5232</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5207</span>

static VALUE
sf_s_ellint_RJ(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c4;
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RJ,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    void *opt;
    if (argc==4) {
        c4 = GSL_MODE_DEFAULT;
    } else if (argc==5) {
        c4 = NUM2INT(v[4]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 4 or 5&quot;,argc);
    }
    opt = &amp;c4; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,4,v[0],v[1],v[2],v[3]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RJ_e-class_method">
  
    .<strong>ellint_RJ_e</strong>(x, y, z, p, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RJ(x,y,z,p)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>p</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5279
5280
5281
5282
5283
5284
5285
5286
5287
5288
5289
5290
5291
5292
5293
5294
5295
5296
5297
5298
5299
5300
5301
5302
5303
5304</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5279</span>

static VALUE
sf_s_ellint_RJ_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c4;
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RJ_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    void *opt;
    if (argc==4) {
        c4 = GSL_MODE_DEFAULT;
    } else if (argc==5) {
        c4 = NUM2INT(v[4]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 4 or 5&quot;,argc);
    }
    opt = &amp;c4; //mode

    
    
    return na_ndloop3(&amp;ndf,opt,4,v[0],v[1],v[2],v[3]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="elljac_e-class_method">
  
    .<strong>elljac_e</strong>(u, m)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Jacobian elliptic functions sn(u|m),
cn(u|m), dn(u|m) by descending Landen
transformations.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>u</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [sn, cn, dn, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7156
7157
7158
7159
7160
7161
7162
7163
7164
7165
7166
7167
7168
7169</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7156</span>

static VALUE
sf_s_elljac_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_elljac_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf-class_method">
  
    .<strong>erf</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the error function $\erf(x)$
erf(x), where
$\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$
erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8573
8574
8575
8576
8577
8578
8579
8580
8581</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8573</span>

static VALUE
sf_s_erf(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erf, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_e-class_method">
  
    .<strong>erf_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the error function $\erf(x)$
erf(x), where
$\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$
erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8617
8618
8619
8620
8621
8622
8623
8624
8625
8626
8627
8628
8629
8630</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8617</span>

static VALUE
sf_s_erf_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erf_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Q-class_method">
  
    .<strong>erf_Q</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the upper tail of the Gaussian probability
function
$Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$
Q(x) = (1/\sqrt[2\pi]) \int_x^\infty dt \exp(-t^2/2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8927
8928
8929
8930
8931
8932
8933
8934
8935</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8927</span>

static VALUE
sf_s_erf_Q(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Q, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Q_e-class_method">
  
    .<strong>erf_Q_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the upper tail of the Gaussian probability
function
$Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$
Q(x) = (1/\sqrt[2\pi]) \int_x^\infty dt \exp(-t^2/2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8971
8972
8973
8974
8975
8976
8977
8978
8979
8980
8981
8982
8983
8984</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8971</span>

static VALUE
sf_s_erf_Q_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Q_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Z-class_method">
  
    .<strong>erf_Z</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gaussian probability density function
$Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$
Z(x) = (1/\sqrt[2\pi]) \exp(-x^2/2).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8838
8839
8840
8841
8842
8843
8844
8845
8846</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8838</span>

static VALUE
sf_s_erf_Z(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Z, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Z_e-class_method">
  
    .<strong>erf_Z_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gaussian probability density function
$Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$
Z(x) = (1/\sqrt[2\pi]) \exp(-x^2/2).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8880
8881
8882
8883
8884
8885
8886
8887
8888
8889
8890
8891
8892
8893</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8880</span>

static VALUE
sf_s_erf_Z_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Z_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erfc-class_method">
  
    .<strong>erfc</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary error function
$\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$
erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8663
8664
8665
8666
8667
8668
8669
8670
8671</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8663</span>

static VALUE
sf_s_erfc(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erfc, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erfc_e-class_method">
  
    .<strong>erfc_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary error function
$\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$
erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8706
8707
8708
8709
8710
8711
8712
8713
8714
8715
8716
8717
8718
8719</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8706</span>

static VALUE
sf_s_erfc_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erfc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta-class_method">
  
    .<strong>eta</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(s) for arbitrary s.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19503
19504
19505
19506
19507
19508
19509
19510
19511</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19503</span>

static VALUE
sf_s_eta(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_eta, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta_e-class_method">
  
    .<strong>eta_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(s) for arbitrary s.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19544
19545
19546
19547
19548
19549
19550
19551
19552
19553
19554
19555
19556
19557</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19544</span>

static VALUE
sf_s_eta_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_eta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta_int-class_method">
  
    .<strong>eta_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(n) for integer n.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19431
19432
19433
19434
19435
19436
19437
19438
19439</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19431</span>

static VALUE
sf_s_eta_int(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_eta_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta_int_e-class_method">
  
    .<strong>eta_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(n) for integer n.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19452
19453
19454
19455
19456
19457
19458
19459
19460
19461
19462
19463
19464
19465
19466
19467
19468
19469
19470
19471
19472</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19452</span>

static VALUE
sf_s_eta_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
    c2 = gsl_sf_eta_int_e(c0,&amp;c1);
    
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp-class_method">
  
    .<strong>exp</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines provide an exponential function \exp(x) using GSL
semantics and error checking.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9210
9211
9212
9213
9214
9215
9216
9217
9218</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9210</span>

static VALUE
sf_s_exp(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exp, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_e-class_method">
  
    .<strong>exp_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines provide an exponential function \exp(x) using GSL
semantics and error checking.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9252
9253
9254
9255
9256
9257
9258
9259
9260
9261
9262
9263
9264
9265</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9252</span>

static VALUE
sf_s_exp_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_e10_e-class_method">
  
    .<strong>exp_e10_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the exponential \exp(x) using the
gsl_sf_result_e10 type to return a result with extended range.
This function may be useful if the value of \exp(x) would
overflow the  numeric range of double.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9301
9302
9303
9304
9305
9306
9307
9308
9309
9310
9311
9312
9313
9314</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9301</span>

static VALUE
sf_s_exp_e10_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_err_e-class_method">
  
    .<strong>exp_err_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function exponentiates x with an associated absolute error
dx.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9875
9876
9877
9878
9879
9880
9881
9882
9883
9884
9885
9886
9887
9888</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9875</span>

static VALUE
sf_s_exp_err_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_err_e10_e-class_method">
  
    .<strong>exp_err_e10_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function exponentiates a quantity x with an associated absolute
error dx using the gsl_sf_result_e10 type to return a result with
extended range.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9926
9927
9928
9929
9930
9931
9932
9933
9934
9935
9936
9937
9938
9939</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9926</span>

static VALUE
sf_s_exp_err_e10_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_err_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult-class_method">
  
    .<strong>exp_mult</strong>(x, y)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines exponentiate x and multiply by the factor y
to return the product y \exp(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9349
9350
9351
9352
9353
9354
9355
9356
9357</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9349</span>

static VALUE
sf_s_exp_mult(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_e-class_method">
  
    .<strong>exp_mult_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines exponentiate x and multiply by the factor y
to return the product y \exp(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9394
9395
9396
9397
9398
9399
9400
9401
9402
9403
9404
9405
9406
9407</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9394</span>

static VALUE
sf_s_exp_mult_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_e10_e-class_method">
  
    .<strong>exp_mult_e10_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the product y \exp(x) using the
gsl_sf_result_e10 type to return a result with extended numeric
range.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9445
9446
9447
9448
9449
9450
9451
9452
9453
9454
9455
9456
9457
9458</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9445</span>

static VALUE
sf_s_exp_mult_e10_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_err_e-class_method">
  
    .<strong>exp_mult_err_e</strong>(x, dx, y, dy)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the product y \exp(x) for the quantities
x, y with associated absolute errors dx, dy.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dy</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9982
9983
9984
9985
9986
9987
9988
9989
9990
9991
9992
9993
9994
9995</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9982</span>

static VALUE
sf_s_exp_mult_err_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_err_e10_e-class_method">
  
    .<strong>exp_mult_err_e10_e</strong>(x, dx, y, dy)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the product y \exp(x) for the quantities
x, y with associated absolute errors dx, dy using the
gsl_sf_result_e10 type to return a result with extended range.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dy</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10039
10040
10041
10042
10043
10044
10045
10046
10047
10048
10049
10050
10051
10052</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10039</span>

static VALUE
sf_s_exp_mult_err_e10_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_err_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,4,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_3-class_method">
  
    .<strong>expint_3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$
Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$
x &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5905
5906
5907
5908
5909
5910
5911
5912
5913</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5905</span>

static VALUE
sf_s_expint_3(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_3_e-class_method">
  
    .<strong>expint_3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$
Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$
x &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5948
5949
5950
5951
5952
5953
5954
5955
5956
5957
5958
5959
5960
5961</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5948</span>

static VALUE
sf_s_expint_3_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E1-class_method">
  
    .<strong>expint_E1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_1(x),</p>

<p>E_1(x) := \Re \int_1^\infty dt \exp(-xt)/t.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5339
5340
5341
5342
5343
5344
5345
5346
5347</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5339</span>

static VALUE
sf_s_expint_E1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E1_e-class_method">
  
    .<strong>expint_E1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_1(x),</p>

<p>E_1(x) := \Re \int_1^\infty dt \exp(-xt)/t.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5384
5385
5386
5387
5388
5389
5390
5391
5392
5393
5394
5395
5396
5397</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5384</span>

static VALUE
sf_s_expint_E1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E2-class_method">
  
    .<strong>expint_E2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order exponential integral E_2(x),</p>

<p>E_2(x) := \Re \int_1^\infty dt \exp(-xt)/t^2.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5432
5433
5434
5435
5436
5437
5438
5439
5440</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5432</span>

static VALUE
sf_s_expint_E2(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E2_e-class_method">
  
    .<strong>expint_E2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order exponential integral E_2(x),</p>

<p>E_2(x) := \Re \int_1^\infty dt \exp(-xt)/t^2.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5477
5478
5479
5480
5481
5482
5483
5484
5485
5486
5487
5488
5489
5490</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5477</span>

static VALUE
sf_s_expint_E2_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_Ei-class_method">
  
    .<strong>expint_Ei</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral $\hboxEi(x)$
Ei(x),</p>

<p>Ei(x) := - PV(\int_[-x]^\infty dt \exp(-t)/t)</p>

<p>where PV denotes the principal value of the integral.
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5634
5635
5636
5637
5638
5639
5640
5641
5642</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5634</span>

static VALUE
sf_s_expint_Ei(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_Ei, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_Ei_e-class_method">
  
    .<strong>expint_Ei_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral $\hboxEi(x)$
Ei(x),</p>

<p>Ei(x) := - PV(\int_[-x]^\infty dt \exp(-t)/t)</p>

<p>where PV denotes the principal value of the integral.
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5681
5682
5683
5684
5685
5686
5687
5688
5689
5690
5691
5692
5693
5694</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5681</span>

static VALUE
sf_s_expint_Ei_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_Ei_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_En-class_method">
  
    .<strong>expint_En</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_n(x) of order n,</p>

<p>E_n(x) := \Re \int_1^\infty dt \exp(-xt)/t^n.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5528
5529
5530
5531
5532
5533
5534
5535
5536
5537
5538
5539</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5528</span>

static VALUE
sf_s_expint_En(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_En, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_En_e-class_method">
  
    .<strong>expint_En_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_n(x) of order n,</p>

<p>E_n(x) := \Re \int_1^\infty dt \exp(-xt)/t^n.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5580
5581
5582
5583
5584
5585
5586
5587
5588
5589
5590
5591
5592
5593
5594
5595
5596
5597</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5580</span>

static VALUE
sf_s_expint_En_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_En_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expm1-class_method">
  
    .<strong>expm1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity \exp(x)-1 using an algorithm
that is accurate for small x.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9490
9491
9492
9493
9494
9495
9496
9497
9498</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9490</span>

static VALUE
sf_s_expm1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expm1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expm1_e-class_method">
  
    .<strong>expm1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity \exp(x)-1 using an algorithm
that is accurate for small x.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9532
9533
9534
9535
9536
9537
9538
9539
9540
9541
9542
9543
9544
9545</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9532</span>

static VALUE
sf_s_expm1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expm1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel-class_method">
  
    .<strong>exprel</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity (\exp(x)-1)/x using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion (\exp(x)-1)/x = 1 + x/2 +
x^2/(2<em>3) + x^3/(2</em>3*4) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9579
9580
9581
9582
9583
9584
9585
9586
9587</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9579</span>

static VALUE
sf_s_exprel(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exprel, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_2-class_method">
  
    .<strong>exprel_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion 2(\exp(x)-1-x)/x^2 =
1 + x/3 + x^2/(3<em>4) + x^3/(3</em>4*5) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9670
9671
9672
9673
9674
9675
9676
9677
9678</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9670</span>

static VALUE
sf_s_exprel_2(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_2_e-class_method">
  
    .<strong>exprel_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion 2(\exp(x)-1-x)/x^2 =
1 + x/3 + x^2/(3<em>4) + x^3/(3</em>4*5) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9714
9715
9716
9717
9718
9719
9720
9721
9722
9723
9724
9725
9726
9727</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9714</span>

static VALUE
sf_s_exprel_2_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_e-class_method">
  
    .<strong>exprel_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity (\exp(x)-1)/x using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion (\exp(x)-1)/x = 1 + x/2 +
x^2/(2<em>3) + x^3/(2</em>3*4) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9623
9624
9625
9626
9627
9628
9629
9630
9631
9632
9633
9634
9635
9636</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9623</span>

static VALUE
sf_s_exprel_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_n-class_method">
  
    .<strong>exprel_n</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the N-relative exponential, which is the
n-th generalization of the functions gsl_sf_exprel and
gsl_sf_exprel_2.  The N-relative exponential is given by,</p>

<p>exprel_N(x) = N!/x^N (\exp(x) - \sum_[k=0]^[N-1] x^k/k!)
          = 1 + x/(N+1) + x^2/((N+1)(N+2)) + …
          = 1F1 (1,1+N,x)
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9767
9768
9769
9770
9771
9772
9773
9774
9775
9776
9777
9778</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9767</span>

static VALUE
sf_s_exprel_n(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_n, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_n_e-class_method">
  
    .<strong>exprel_n_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the N-relative exponential, which is the
n-th generalization of the functions gsl_sf_exprel and
gsl_sf_exprel_2.  The N-relative exponential is given by,</p>

<p>exprel_N(x) = N!/x^N (\exp(x) - \sum_[k=0]^[N-1] x^k/k!)
          = 1 + x/(N+1) + x^2/((N+1)(N+2)) + …
          = 1F1 (1,1+N,x)
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9821
9822
9823
9824
9825
9826
9827
9828
9829
9830
9831
9832
9833
9834
9835
9836
9837
9838</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9821</span>

static VALUE
sf_s_exprel_n_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fact-class_method">
  
    .<strong>fact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the factorial n!.  The factorial is
related to the Gamma function by n! = \Gamma(n+1).
The maximum value of n such that n! is not
considered an overflow is given by the macro GSL_SF_FACT_NMAX
and is 170.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1935
1936
1937
1938
1939
1940
1941
1942
1943</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1935</span>

static VALUE
sf_s_fact(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fact_e-class_method">
  
    .<strong>fact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the factorial n!.  The factorial is
related to the Gamma function by n! = \Gamma(n+1).
The maximum value of n such that n! is not
considered an overflow is given by the macro GSL_SF_FACT_NMAX
and is 170.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1980
1981
1982
1983
1984
1985
1986
1987
1988
1989
1990
1991
1992
1993</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1980</span>

static VALUE
sf_s_fact_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_0-class_method">
  
    .<strong>fermi_dirac_0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 0.
This integral is given by F_0(x) = \ln(1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11279
11280
11281
11282
11283
11284
11285
11286
11287</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11279</span>

static VALUE
sf_s_fermi_dirac_0(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_0_e-class_method">
  
    .<strong>fermi_dirac_0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 0.
This integral is given by F_0(x) = \ln(1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11321
11322
11323
11324
11325
11326
11327
11328
11329
11330
11331
11332
11333
11334</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11321</span>

static VALUE
sf_s_fermi_dirac_0_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_1-class_method">
  
    .<strong>fermi_dirac_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 1,
F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11366
11367
11368
11369
11370
11371
11372
11373
11374</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11366</span>

static VALUE
sf_s_fermi_dirac_1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_1_e-class_method">
  
    .<strong>fermi_dirac_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 1,
F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11408
11409
11410
11411
11412
11413
11414
11415
11416
11417
11418
11419
11420
11421</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11408</span>

static VALUE
sf_s_fermi_dirac_1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_2-class_method">
  
    .<strong>fermi_dirac_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index
of 2,
F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11454
11455
11456
11457
11458
11459
11460
11461
11462</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11454</span>

static VALUE
sf_s_fermi_dirac_2(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_2_e-class_method">
  
    .<strong>fermi_dirac_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index
of 2,
F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11497
11498
11499
11500
11501
11502
11503
11504
11505
11506
11507
11508
11509
11510</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11497</span>

static VALUE
sf_s_fermi_dirac_2_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_3half-class_method">
  
    .<strong>fermi_dirac_3half</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_3/2(x)$
F_<a href="x">3/2</a>.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11826
11827
11828
11829
11830
11831
11832
11833
11834</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11826</span>

static VALUE
sf_s_fermi_dirac_3half(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_3half, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_3half_e-class_method">
  
    .<strong>fermi_dirac_3half_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_3/2(x)$
F_<a href="x">3/2</a>.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11869
11870
11871
11872
11873
11874
11875
11876
11877
11878
11879
11880
11881
11882</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11869</span>

static VALUE
sf_s_fermi_dirac_3half_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_3half_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_half-class_method">
  
    .<strong>fermi_dirac_half</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_1/2(x)$
F_<a href="x">1/2</a>.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11737
11738
11739
11740
11741
11742
11743
11744
11745</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11737</span>

static VALUE
sf_s_fermi_dirac_half(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_half, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_half_e-class_method">
  
    .<strong>fermi_dirac_half_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_1/2(x)$
F_<a href="x">1/2</a>.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11780
11781
11782
11783
11784
11785
11786
11787
11788
11789
11790
11791
11792
11793</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11780</span>

static VALUE
sf_s_fermi_dirac_half_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_half_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_inc_0-class_method">
  
    .<strong>fermi_dirac_inc_0</strong>(x, b)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete Fermi-Dirac integral with an index
of zero,
$F_0(x,b) = \ln(1 + e^b-x) - (b-x)$
F_0(x,b) = \ln(1 + e^[b-x]) - (b-x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11919
11920
11921
11922
11923
11924
11925
11926
11927</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11919</span>

static VALUE
sf_s_fermi_dirac_inc_0(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_inc_0, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_inc_0_e-class_method">
  
    .<strong>fermi_dirac_inc_0_e</strong>(x, b)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete Fermi-Dirac integral with an index
of zero,
$F_0(x,b) = \ln(1 + e^b-x) - (b-x)$
F_0(x,b) = \ln(1 + e^[b-x]) - (b-x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11966
11967
11968
11969
11970
11971
11972
11973
11974
11975
11976
11977
11978
11979</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11966</span>

static VALUE
sf_s_fermi_dirac_inc_0_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_inc_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_int-class_method">
  
    .<strong>fermi_dirac_int</strong>(j, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an integer
index of j,
F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).
Complete integral F_j(x) for integer j
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11547
11548
11549
11550
11551
11552
11553
11554
11555
11556
11557
11558</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11547</span>

static VALUE
sf_s_fermi_dirac_int(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_int_e-class_method">
  
    .<strong>fermi_dirac_int_e</strong>(j, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an integer
index of j,
F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).
Complete integral F_j(x) for integer j
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11598
11599
11600
11601
11602
11603
11604
11605
11606
11607
11608
11609
11610
11611
11612
11613
11614
11615</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11598</span>

static VALUE
sf_s_fermi_dirac_int_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //j
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_m1-class_method">
  
    .<strong>fermi_dirac_m1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of -1.
This integral is given by
$F_-1(x) = e^x / (1 + e^x)$
F_<a href="x">-1</a> = e^x / (1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11190
11191
11192
11193
11194
11195
11196
11197
11198</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11190</span>

static VALUE
sf_s_fermi_dirac_m1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_m1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_m1_e-class_method">
  
    .<strong>fermi_dirac_m1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of -1.
This integral is given by
$F_-1(x) = e^x / (1 + e^x)$
F_<a href="x">-1</a> = e^x / (1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11234
11235
11236
11237
11238
11239
11240
11241
11242
11243
11244
11245
11246
11247</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11234</span>

static VALUE
sf_s_fermi_dirac_m1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_m1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_mhalf-class_method">
  
    .<strong>fermi_dirac_mhalf</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_-1/2(x)$
F_<a href="x">-1/2</a>.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11648
11649
11650
11651
11652
11653
11654
11655
11656</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11648</span>

static VALUE
sf_s_fermi_dirac_mhalf(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_mhalf, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_mhalf_e-class_method">
  
    .<strong>fermi_dirac_mhalf_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_-1/2(x)$
F_<a href="x">-1/2</a>.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11691
11692
11693
11694
11695
11696
11697
11698
11699
11700
11701
11702
11703
11704</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11691</span>

static VALUE
sf_s_fermi_dirac_mhalf_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_mhalf_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma-class_method">
  
    .<strong>gamma</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gamma function \Gamma(x), subject to x
not being a negative integer or zero.  The function is computed using the real
Lanczos method. The maximum value of x such that \Gamma(x) is not
considered an overflow is given by the macro GSL_SF_GAMMA_XMAX
and is 171.0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1453
1454
1455
1456
1457
1458
1459
1460
1461</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1453</span>

static VALUE
sf_s_gamma(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_e-class_method">
  
    .<strong>gamma_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gamma function \Gamma(x), subject to x
not being a negative integer or zero.  The function is computed using the real
Lanczos method. The maximum value of x such that \Gamma(x) is not
considered an overflow is given by the macro GSL_SF_GAMMA_XMAX
and is 171.0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1498
1499
1500
1501
1502
1503
1504
1505
1506
1507
1508
1509
1510
1511</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1498</span>

static VALUE
sf_s_gamma_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc-class_method">
  
    .<strong>gamma_inc</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the unnormalized incomplete Gamma Function
$\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$
\Gamma(a,x) = \int_x^\infty dt t^[a-1] \exp(-t)
for a real and $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2943
2944
2945
2946
2947
2948
2949
2950
2951</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2943</span>

static VALUE
sf_s_gamma_inc(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_e-class_method">
  
    .<strong>gamma_inc_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the unnormalized incomplete Gamma Function
$\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$
\Gamma(a,x) = \int_x^\infty dt t^[a-1] \exp(-t)
for a real and $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2991
2992
2993
2994
2995
2996
2997
2998
2999
3000
3001
3002
3003
3004</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2991</span>

static VALUE
sf_s_gamma_inc_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_P-class_method">
  
    .<strong>gamma_inc_P</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary normalized incomplete Gamma Function
$P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$
P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^[a-1] \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.</p>

<p>Note that Abramowitz &amp; Stegun call P(a,x) the incomplete gamma
function (section 6.5).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3144
3145
3146
3147
3148
3149
3150
3151
3152</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3144</span>

static VALUE
sf_s_gamma_inc_P(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_P, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_P_e-class_method">
  
    .<strong>gamma_inc_P_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary normalized incomplete Gamma Function
$P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$
P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^[a-1] \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.</p>

<p>Note that Abramowitz &amp; Stegun call P(a,x) the incomplete gamma
function (section 6.5).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3195
3196
3197
3198
3199
3200
3201
3202
3203
3204
3205
3206
3207
3208</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3195</span>

static VALUE
sf_s_gamma_inc_P_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_P_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_Q-class_method">
  
    .<strong>gamma_inc_Q</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Gamma Function
$Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$
Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^[a-1] \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3042
3043
3044
3045
3046
3047
3048
3049
3050</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3042</span>

static VALUE
sf_s_gamma_inc_Q(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_Q, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_Q_e-class_method">
  
    .<strong>gamma_inc_Q_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Gamma Function
$Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$
Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^[a-1] \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3090
3091
3092
3093
3094
3095
3096
3097
3098
3099
3100
3101
3102
3103</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3090</span>

static VALUE
sf_s_gamma_inc_Q_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_Q_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammainv-class_method">
  
    .<strong>gammainv</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the reciprocal of the gamma function,
1/\Gamma(x) using the real Lanczos method.
exceptions: GSL_EUNDRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1785
1786
1787
1788
1789
1790
1791
1792
1793</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1785</span>

static VALUE
sf_s_gammainv(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gammainv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammainv_e-class_method">
  
    .<strong>gammainv_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the reciprocal of the gamma function,
1/\Gamma(x) using the real Lanczos method.
exceptions: GSL_EUNDRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1827
1828
1829
1830
1831
1832
1833
1834
1835
1836
1837
1838
1839
1840</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1827</span>

static VALUE
sf_s_gammainv_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gammainv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammastar-class_method">
  
    .<strong>gammastar</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regulated Gamma Function \Gamma^*(x)
for x &gt; 0. The regulated gamma function is given by,</p>

<p>\Gamma^*(x) = \Gamma(x)/(\sqrt[2\pi] x^[(x-1/2)] \exp(-x))
          = (1 + (1/12x) + …)  for x \to \infty
and is a useful suggestion of Temme.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1694
1695
1696
1697
1698
1699
1700
1701
1702</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1694</span>

static VALUE
sf_s_gammastar(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gammastar, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammastar_e-class_method">
  
    .<strong>gammastar_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regulated Gamma Function \Gamma^*(x)
for x &gt; 0. The regulated gamma function is given by,</p>

<p>\Gamma^*(x) = \Gamma(x)/(\sqrt[2\pi] x^[(x-1/2)] \exp(-x))
          = (1 + (1/12x) + …)  for x \to \infty
and is a useful suggestion of Temme.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1740
1741
1742
1743
1744
1745
1746
1747
1748
1749
1750
1751
1752
1753</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1740</span>

static VALUE
sf_s_gammastar_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gammastar_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_1-class_method">
  
    .<strong>gegenpoly_1</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^[(\lambda)]_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6671
6672
6673
6674
6675
6676
6677
6678
6679</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6671</span>

static VALUE
sf_s_gegenpoly_1(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_1_e-class_method">
  
    .<strong>gegenpoly_1_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^[(\lambda)]_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6808
6809
6810
6811
6812
6813
6814
6815
6816
6817
6818
6819
6820
6821</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6808</span>

static VALUE
sf_s_gegenpoly_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_2-class_method">
  
    .<strong>gegenpoly_2</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^[(\lambda)]_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6716
6717
6718
6719
6720
6721
6722
6723
6724</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6716</span>

static VALUE
sf_s_gegenpoly_2(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_2, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_2_e-class_method">
  
    .<strong>gegenpoly_2_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^[(\lambda)]_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6860
6861
6862
6863
6864
6865
6866
6867
6868
6869
6870
6871
6872
6873</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6860</span>

static VALUE
sf_s_gegenpoly_2_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_3-class_method">
  
    .<strong>gegenpoly_3</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^[(\lambda)]_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6761
6762
6763
6764
6765
6766
6767
6768
6769</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6761</span>

static VALUE
sf_s_gegenpoly_3(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_3, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_3_e-class_method">
  
    .<strong>gegenpoly_3_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^[(\lambda)]_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6912
6913
6914
6915
6916
6917
6918
6919
6920
6921
6922
6923
6924
6925</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6912</span>

static VALUE
sf_s_gegenpoly_3_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_array-class_method">
  
    .<strong>gegenpoly_array</strong>(nmax, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes an array of Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^[(\lambda)]_n(x) for n = 0, 1, 2, \dots, nmax, subject
to \lambda &gt; -1/2, $nmax \ge 0$
nmax &gt;= 0.
Conditions: n = 0, 1, 2, … nmax
Domain: lambda &gt; -1/2, nmax &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7090
7091
7092
7093
7094
7095
7096
7097
7098
7099
7100
7101
7102
7103
7104
7105
7106
7107
7108
7109
7110
7111
7112</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7090</span>

static VALUE
sf_s_gegenpoly_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //nmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_n-class_method">
  
    .<strong>gegenpoly_n</strong>(n, lambda, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$
C^[(\lambda)]_n(x) for a specific value of n,
lambda, x subject to \lambda &gt; -1/2, $n \ge 0$
n &gt;= 0.
Domain: lambda &gt; -1/2, n &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6966
6967
6968
6969
6970
6971
6972
6973
6974
6975
6976
6977
6978
6979
6980
6981
6982
6983</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6966</span>

static VALUE
sf_s_gegenpoly_n(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_n,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_n_e-class_method">
  
    .<strong>gegenpoly_n_e</strong>(n, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$
C^[(\lambda)]_n(x) for a specific value of n,
lambda, x subject to \lambda &gt; -1/2, $n \ge 0$
n &gt;= 0.
Domain: lambda &gt; -1/2, n &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7027
7028
7029
7030
7031
7032
7033
7034
7035
7036
7037
7038
7039
7040
7041
7042
7043
7044</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7027</span>

static VALUE
sf_s_gegenpoly_n_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hazard-class_method">
  
    .<strong>hazard</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hazard function for the normal distribution.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9015
9016
9017
9018
9019
9020
9021
9022
9023</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9015</span>

static VALUE
sf_s_hazard(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hazard, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hazard_e-class_method">
  
    .<strong>hazard_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hazard function for the normal distribution.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9056
9057
9058
9059
9060
9061
9062
9063
9064
9065
9066
9067
9068
9069</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9056</span>

static VALUE
sf_s_hazard_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hazard_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR-class_method">
  
    .<strong>hydrogenicR</strong>(n, l, Z, r)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the n-th normalized hydrogenic bound state
radial wavefunction,</p>

<p>R_n := 2 (Z^[3/2]/n^2) \sqrt[(n-l-1)!/(n+l)!] \exp(-Z r/n) (2Zr/n)^l
        L^[2l+1]_<a href="2Zr/n">n-l-1</a>.</p>

<p>where L^a_b(x) is the generalized Laguerre polynomial (Laguerre Functions).
The normalization is chosen such that the wavefunction \psi is
given by
$\psi(n,l,r) = R_n Y_lm$
\psi(n,l,r) = R_n Y_[lm].</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17121
17122
17123
17124
17125
17126
17127
17128
17129
17130
17131
17132
17133</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17121</span>

static VALUE
sf_s_hydrogenicR(VALUE mod, VALUE v0, VALUE v1, VALUE v2, VALUE v3)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};
    int opts[2];

    opts[0] = NUM2INT(v0);
    opts[1] = NUM2INT(v1);

    return na_ndloop3(&amp;ndf, opts, 2, v2, v3);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR_1-class_method">
  
    .<strong>hydrogenicR_1</strong>(Z, r)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the lowest-order normalized hydrogenic bound
state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$
R_1 := 2Z \sqrt[Z] \exp(-Z r).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17016
17017
17018
17019
17020
17021
17022
17023
17024</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17016</span>

static VALUE
sf_s_hydrogenicR_1(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR_1_e-class_method">
  
    .<strong>hydrogenicR_1_e</strong>(Z, r)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the lowest-order normalized hydrogenic bound
state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$
R_1 := 2Z \sqrt[Z] \exp(-Z r).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17061
17062
17063
17064
17065
17066
17067
17068
17069
17070
17071
17072
17073
17074</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17061</span>

static VALUE
sf_s_hydrogenicR_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR_e-class_method">
  
    .<strong>hydrogenicR_e</strong>(n, l, Z, r)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the n-th normalized hydrogenic bound state
radial wavefunction,</p>

<p>R_n := 2 (Z^[3/2]/n^2) \sqrt[(n-l-1)!/(n+l)!] \exp(-Z r/n) (2Zr/n)^l
        L^[2l+1]_<a href="2Zr/n">n-l-1</a>.</p>

<p>where L^a_b(x) is the generalized Laguerre polynomial (Laguerre Functions).
The normalization is chosen such that the wavefunction \psi is
given by
$\psi(n,l,r) = R_n Y_lm$
\psi(n,l,r) = R_n Y_[lm].</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17187
17188
17189
17190
17191
17192
17193
17194
17195
17196
17197
17198
17199
17200
17201
17202
17203
17204
17205
17206
17207</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17187</span>

static VALUE
sf_s_hydrogenicR_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //n
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //l
    
    
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_0F1-class_method">
  
    .<strong>hyperg_0F1</strong>(c, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}<em>0F_1(c,x)$
0F1(c,x).
It is related to Bessel functions
0F1[c,x] =
Gamma[c]    x^(1/2(1-c)) I</em>(c-1)(2 Sqrt[x])
Gamma[c] (-x)^(1/2(1-c)) J_(c-1)(2 Sqrt[-x])
exceptions: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22516
22517
22518
22519
22520
22521
22522
22523
22524</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22516</span>

static VALUE
sf_s_hyperg_0F1(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_0F1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_0F1_e-class_method">
  
    .<strong>hyperg_0F1_e</strong>(c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}<em>0F_1(c,x)$
0F1(c,x).
It is related to Bessel functions
0F1[c,x] =
Gamma[c]    x^(1/2(1-c)) I</em>(c-1)(2 Sqrt[x])
Gamma[c] (-x)^(1/2(1-c)) J_(c-1)(2 Sqrt[-x])
exceptions: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22565
22566
22567
22568
22569
22570
22571
22572
22573
22574
22575
22576
22577
22578</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22565</span>

static VALUE
sf_s_hyperg_0F1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_0F1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1-class_method">
  
    .<strong>hyperg_1F1</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(a,b,x) = M(a,b,x)$
1F1(a,b,x) = M(a,b,x) for general parameters a, b.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22742
22743
22744
22745
22746
22747
22748
22749
22750</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22742</span>

static VALUE
sf_s_hyperg_1F1(VALUE mod, VALUE v0, VALUE v1, VALUE v2)
{
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1_e-class_method">
  
    .<strong>hyperg_1F1_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(a,b,x) = M(a,b,x)$
1F1(a,b,x) = M(a,b,x) for general parameters a, b.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22791
22792
22793
22794
22795
22796
22797
22798
22799
22800
22801
22802
22803
22804</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22791</span>

static VALUE
sf_s_hyperg_1F1_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1_int-class_method">
  
    .<strong>hyperg_1F1_int</strong>(m, n, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(m,n,x) = M(m,n,x)$
1F1(m,n,x) = M(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22619
22620
22621
22622
22623
22624
22625
22626
22627
22628
22629
22630
22631
22632
22633
22634
22635
22636
22637
22638
22639</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22619</span>

static VALUE
sf_s_hyperg_1F1_int(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1_int,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1_int_e-class_method">
  
    .<strong>hyperg_1F1_int_e</strong>(m, n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(m,n,x) = M(m,n,x)$
1F1(m,n,x) = M(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22683
22684
22685
22686
22687
22688
22689
22690
22691
22692
22693
22694
22695
22696
22697
22698
22699
22700
22701
22702
22703</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22683</span>

static VALUE
sf_s_hyperg_1F1_int_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F0-class_method">
  
    .<strong>hyperg_2F0</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$
2F0(a,b,x).  The series representation
is a divergent hypergeometric series.  However, for x &lt; 0 we
have
${}_2F_0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)$
2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23637
23638
23639
23640
23641
23642
23643
23644
23645</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23637</span>

static VALUE
sf_s_hyperg_2F0(VALUE mod, VALUE v0, VALUE v1, VALUE v2)
{
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F0, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F0_e-class_method">
  
    .<strong>hyperg_2F0_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$
2F0(a,b,x).  The series representation
is a divergent hypergeometric series.  However, for x &lt; 0 we
have
${}_2F_0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)$
2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23689
23690
23691
23692
23693
23694
23695
23696
23697
23698
23699
23700
23701
23702</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23689</span>

static VALUE
sf_s_hyperg_2F0_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1-class_method">
  
    .<strong>hyperg_2F1</strong>(a, b, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a,b,c,x) = F(a,b,c,x)$
2F1(a,b,c,x) = F(a,b,c,x) for |x| &lt; 1.</p>

<p>If the arguments (a,b,c,x) are too close to a singularity then
the function can return the error code GSL_EMAXITER when the
series approximation converges too slowly.  This occurs in the region of
x=1, c - a - b = m for integer m.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23187
23188
23189
23190
23191
23192
23193
23194
23195
23196
23197
23198
23199
23200</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23187</span>

static VALUE
sf_s_hyperg_2F1(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj-class_method">
  
    .<strong>hyperg_2F1_conj</strong>(aR, aI, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a_R + i a_I, aR - i aI, c, x)$
2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters
for |x| &lt; 1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23303
23304
23305
23306
23307
23308
23309
23310
23311
23312
23313
23314
23315
23316</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23303</span>

static VALUE
sf_s_hyperg_2F1_conj(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj_e-class_method">
  
    .<strong>hyperg_2F1_conj_e</strong>(aR, aI, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a_R + i a_I, aR - i aI, c, x)$
2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters
for |x| &lt; 1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23360
23361
23362
23363
23364
23365
23366
23367
23368
23369
23370
23371
23372
23373</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23360</span>

static VALUE
sf_s_hyperg_2F1_conj_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj_renorm-class_method">
  
    .<strong>hyperg_2F1_conj_renorm</strong>(aR, aI, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$
2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23525
23526
23527
23528
23529
23530
23531
23532
23533
23534
23535
23536
23537
23538</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23525</span>

static VALUE
sf_s_hyperg_2F1_conj_renorm(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj_renorm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj_renorm_e-class_method">
  
    .<strong>hyperg_2F1_conj_renorm_e</strong>(aR, aI, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$
2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23582
23583
23584
23585
23586
23587
23588
23589
23590
23591
23592
23593
23594
23595</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23582</span>

static VALUE
sf_s_hyperg_2F1_conj_renorm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj_renorm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_e-class_method">
  
    .<strong>hyperg_2F1_e</strong>(a, b, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a,b,c,x) = F(a,b,c,x)$
2F1(a,b,c,x) = F(a,b,c,x) for |x| &lt; 1.</p>

<p>If the arguments (a,b,c,x) are too close to a singularity then
the function can return the error code GSL_EMAXITER when the
series approximation converges too slowly.  This occurs in the region of
x=1, c - a - b = m for integer m.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23249
23250
23251
23252
23253
23254
23255
23256
23257
23258
23259
23260
23261
23262</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23249</span>

static VALUE
sf_s_hyperg_2F1_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_renorm-class_method">
  
    .<strong>hyperg_2F1_renorm</strong>(a, b, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a,b,c,x) / \Gamma(c)$
2F1(a,b,c,x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23414
23415
23416
23417
23418
23419
23420
23421
23422
23423
23424
23425
23426
23427</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23414</span>

static VALUE
sf_s_hyperg_2F1_renorm(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_renorm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_renorm_e-class_method">
  
    .<strong>hyperg_2F1_renorm_e</strong>(a, b, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a,b,c,x) / \Gamma(c)$
2F1(a,b,c,x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23471
23472
23473
23474
23475
23476
23477
23478
23479
23480
23481
23482
23483
23484</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23471</span>

static VALUE
sf_s_hyperg_2F1_renorm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_renorm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U-class_method">
  
    .<strong>hyperg_U</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function U(a,b,x).
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23027
23028
23029
23030
23031
23032
23033
23034
23035</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23027</span>

static VALUE
sf_s_hyperg_U(VALUE mod, VALUE v0, VALUE v1, VALUE v2)
{
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_e-class_method">
  
    .<strong>hyperg_U_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function U(a,b,x).
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23074
23075
23076
23077
23078
23079
23080
23081
23082
23083
23084
23085
23086
23087</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23074</span>

static VALUE
sf_s_hyperg_U_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_e10_e-class_method">
  
    .<strong>hyperg_U_e10_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the confluent hypergeometric function
U(a,b,x) using the gsl_sf_result_e10 type to return a
result with extended range.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23128
23129
23130
23131
23132
23133
23134
23135
23136
23137
23138
23139
23140
23141</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23128</span>

static VALUE
sf_s_hyperg_U_e10_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,4,ain,aout};
    
    
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_int-class_method">
  
    .<strong>hyperg_U_int</strong>(m, n, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
U(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22844
22845
22846
22847
22848
22849
22850
22851
22852
22853
22854
22855
22856
22857
22858
22859
22860
22861
22862
22863
22864</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22844</span>

static VALUE
sf_s_hyperg_U_int(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_int,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_int_e-class_method">
  
    .<strong>hyperg_U_int_e</strong>(m, n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
U(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22907
22908
22909
22910
22911
22912
22913
22914
22915
22916
22917
22918
22919
22920
22921
22922
22923
22924
22925
22926
22927</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22907</span>

static VALUE
sf_s_hyperg_U_int_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_int_e10_e-class_method">
  
    .<strong>hyperg_U_int_e10_e</strong>(m, n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the confluent hypergeometric function
U(m,n,x) for integer parameters m, n using the
gsl_sf_result_e10 type to return a result with extended range.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22970
22971
22972
22973
22974
22975
22976
22977
22978
22979
22980
22981
22982
22983
22984
22985
22986
22987
22988
22989
22990</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22970</span>

static VALUE
sf_s_hyperg_U_int_e10_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_int_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hypot-class_method">
  
    .<strong>hypot</strong>(x, y)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypotenuse function $\sqrt+ y^2$
\sqrt[x^2 + y^2] avoiding overflow and underflow.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


639
640
641
642
643
644
645
646
647</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 639</span>

static VALUE
sf_s_hypot(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hypot, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hypot_e-class_method">
  
    .<strong>hypot_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypotenuse function $\sqrt+ y^2$
\sqrt[x^2 + y^2] avoiding overflow and underflow.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


684
685
686
687
688
689
690
691
692
693
694
695
696
697</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 684</span>

static VALUE
sf_s_hypot_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hypot_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hzeta-class_method">
  
    .<strong>hzeta</strong>(s, q)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Hurwitz zeta function \zeta(s,q) for
s &gt; 1, q &gt; 0.
Domain: s &gt; 1.0, q &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19340
19341
19342
19343
19344
19345
19346
19347
19348</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19340</span>

static VALUE
sf_s_hzeta(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hzeta, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hzeta_e-class_method">
  
    .<strong>hzeta_e</strong>(s, q)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Hurwitz zeta function \zeta(s,q) for
s &gt; 1, q &gt; 0.
Domain: s &gt; 1.0, q &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19386
19387
19388
19389
19390
19391
19392
19393
19394
19395
19396
19397
19398
19399</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19386</span>

static VALUE
sf_s_hzeta_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hzeta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_1-class_method">
  
    .<strong>laguerre_1</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6262
6263
6264
6265
6266
6267
6268
6269
6270</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6262</span>

static VALUE
sf_s_laguerre_1(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_1_e-class_method">
  
    .<strong>laguerre_1_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6396
6397
6398
6399
6400
6401
6402
6403
6404
6405
6406
6407
6408
6409</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6396</span>

static VALUE
sf_s_laguerre_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_2-class_method">
  
    .<strong>laguerre_2</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6306
6307
6308
6309
6310
6311
6312
6313
6314</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6306</span>

static VALUE
sf_s_laguerre_2(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_2, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_2_e-class_method">
  
    .<strong>laguerre_2_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6447
6448
6449
6450
6451
6452
6453
6454
6455
6456
6457
6458
6459
6460</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6447</span>

static VALUE
sf_s_laguerre_2_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_3-class_method">
  
    .<strong>laguerre_3</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6350
6351
6352
6353
6354
6355
6356
6357
6358</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6350</span>

static VALUE
sf_s_laguerre_3(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_3, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_3_e-class_method">
  
    .<strong>laguerre_3_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6498
6499
6500
6501
6502
6503
6504
6505
6506
6507
6508
6509
6510
6511</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6498</span>

static VALUE
sf_s_laguerre_3_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_n-class_method">
  
    .<strong>laguerre_n</strong>(n, a, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_n(x) for a &gt; -1,
$n \ge 0$
n &gt;= 0.</p>

<p>Domain: a &gt; -1.0, n &gt;= 0
Evaluate generalized Laguerre polynomials.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6554
6555
6556
6557
6558
6559
6560
6561
6562
6563
6564
6565
6566
6567
6568
6569
6570
6571</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6554</span>

static VALUE
sf_s_laguerre_n(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_n,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_n_e-class_method">
  
    .<strong>laguerre_n_e</strong>(n, a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_n(x) for a &gt; -1,
$n \ge 0$
n &gt;= 0.</p>

<p>Domain: a &gt; -1.0, n &gt;= 0
Evaluate generalized Laguerre polynomials.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6617
6618
6619
6620
6621
6622
6623
6624
6625
6626
6627
6628
6629
6630
6631
6632
6633
6634</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6617</span>

static VALUE
sf_s_laguerre_n_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_W0-class_method">
  
    .<strong>lambert_W0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the principal branch of the Lambert W function, W_0(x).
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23816
23817
23818
23819
23820
23821
23822
23823
23824</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23816</span>

static VALUE
sf_s_lambert_W0(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_W0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_W0_e-class_method">
  
    .<strong>lambert_W0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the principal branch of the Lambert W function, W_0(x).
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23857
23858
23859
23860
23861
23862
23863
23864
23865
23866
23867
23868
23869
23870</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23857</span>

static VALUE
sf_s_lambert_W0_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_W0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_Wm1-class_method">
  
    .<strong>lambert_Wm1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the secondary real-valued branch of the Lambert W function,
$W_-1(x)$
W_<a href="x">-1</a>.
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23903
23904
23905
23906
23907
23908
23909
23910
23911</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23903</span>

static VALUE
sf_s_lambert_Wm1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_Wm1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_Wm1_e-class_method">
  
    .<strong>lambert_Wm1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the secondary real-valued branch of the Lambert W function,
$W_-1(x)$
W_<a href="x">-1</a>.
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23946
23947
23948
23949
23950
23951
23952
23953
23954
23955
23956
23957
23958
23959</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23946</span>

static VALUE
sf_s_lambert_Wm1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_Wm1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array-class_method">
  
    .<strong>legendre_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
polynomials for 0 \le l \le lmax and
0 \le m \le l for
$|x| \le 1$
|x| &lt;= 1.
The norm parameter specifies which normalization is used.
The normalized P_l^m(x) values are stored in result_array, whose
minimum size can be obtained from calling gsl_sf_legendre_array_n.
The array index of P_l^m(x) is obtained from calling
gsl_sf_legendre_array_index(l, m). To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20398
20399
20400
20401
20402
20403
20404
20405
20406
20407
20408
20409
20410
20411
20412
20413
20414
20415
20416
20417
20418
20419</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20398</span>

static VALUE
sf_s_legendre_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array_e-class_method">
  
    .<strong>legendre_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
polynomials for 0 \le l \le lmax and
0 \le m \le l for
$|x| \le 1$
|x| &lt;= 1.
The norm parameter specifies which normalization is used.
The normalized P_l^m(x) values are stored in result_array, whose
minimum size can be obtained from calling gsl_sf_legendre_array_n.
The array index of P_l^m(x) is obtained from calling
gsl_sf_legendre_array_index(l, m). To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20475
20476
20477
20478
20479
20480
20481
20482
20483
20484
20485
20486
20487
20488
20489
20490
20491
20492
20493
20494
20495
20496
20497
20498</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20475</span>

static VALUE
sf_s_legendre_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array_index-class_method">
  
    .<strong>legendre_array_index</strong>(l, m)  &#x21d2; <tt>Integer</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the index into result_array,
result_deriv_array, or result_deriv2_array corresponding
to P_l^m(x), P_l^‘m(x), or P_l^‘‘m(x). The
index is given by l(l+1)/2 + m.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21186
21187
21188
21189
21190
21191
21192
21193
21194
21195
21196
21197
21198
21199
21200</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21186</span>

static VALUE
sf_s_legendre_array_index(VALUE mod,VALUE v0,VALUE v1)
{
    
    size_t c0;
    size_t c1;
    size_t c2;
    
    c0 = NUM2SIZET(v0);
    c1 = NUM2SIZET(v1);
    c2 = gsl_sf_legendre_array_index(c0,c1);
    
    return SIZET2NUM(c2);
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array_n-class_method">
  
    .<strong>legendre_array_n</strong>(lmax)  &#x21d2; <tt>Integer</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the minimum array size for maximum degree lmax
needed for the array versions of the associated Legendre functions.
Size is calculated as the total number of P_l^m(x) functions,
plus extra space for precomputing multiplicative factors used in the
recurrence relations.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21158
21159
21160
21161
21162
21163
21164
21165
21166
21167
21168
21169
21170</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21158</span>

static VALUE
sf_s_legendre_array_n(VALUE mod,VALUE v0)
{
    
    size_t c0;
    size_t c1;
    
    c0 = NUM2SIZET(v0);
    c1 = gsl_sf_legendre_array_n(c0);
    
    return SIZET2NUM(c1);
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_alt_array-class_method">
  
    .<strong>legendre_deriv2_alt_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first and second derivatives up to degree
lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(\cos\theta)/d\theta, and their second derivatives
d^2 P_l^m(\cos\theta)/d\theta^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21035
21036
21037
21038
21039
21040
21041
21042
21043
21044
21045
21046
21047
21048
21049
21050
21051
21052
21053
21054
21055
21056</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21035</span>

static VALUE
sf_s_legendre_deriv2_alt_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_alt_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_alt_array_e-class_method">
  
    .<strong>legendre_deriv2_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first and second derivatives up to degree
lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(\cos\theta)/d\theta, and their second derivatives
d^2 P_l^m(\cos\theta)/d\theta^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21119
21120
21121
21122
21123
21124
21125
21126
21127
21128
21129
21130
21131
21132
21133
21134
21135
21136
21137
21138
21139
21140
21141
21142</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21119</span>

static VALUE
sf_s_legendre_deriv2_alt_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_alt_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_array-class_method">
  
    .<strong>legendre_deriv2_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first and second derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(x)/dx, and their second derivatives
d^2 P_l^m(x)/dx^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20869
20870
20871
20872
20873
20874
20875
20876
20877
20878
20879
20880
20881
20882
20883
20884
20885
20886
20887
20888
20889
20890</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20869</span>

static VALUE
sf_s_legendre_deriv2_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_array_e-class_method">
  
    .<strong>legendre_deriv2_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first and second derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(x)/dx, and their second derivatives
d^2 P_l^m(x)/dx^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20952
20953
20954
20955
20956
20957
20958
20959
20960
20961
20962
20963
20964
20965
20966
20967
20968
20969
20970
20971
20972
20973
20974
20975</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20952</span>

static VALUE
sf_s_legendre_deriv2_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_alt_array-class_method">
  
    .<strong>legendre_deriv_alt_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The normalized P_l^m(x) values and their derivatives
dP_l^m(\cos\theta)/d\theta are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20709
20710
20711
20712
20713
20714
20715
20716
20717
20718
20719
20720
20721
20722
20723
20724
20725
20726
20727
20728
20729
20730</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20709</span>

static VALUE
sf_s_legendre_deriv_alt_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_alt_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_alt_array_e-class_method">
  
    .<strong>legendre_deriv_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The normalized P_l^m(x) values and their derivatives
dP_l^m(\cos\theta)/d\theta are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20787
20788
20789
20790
20791
20792
20793
20794
20795
20796
20797
20798
20799
20800
20801
20802
20803
20804
20805
20806
20807
20808
20809
20810</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20787</span>

static VALUE
sf_s_legendre_deriv_alt_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_alt_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_array-class_method">
  
    .<strong>legendre_deriv_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x) values and their derivatives
dP_l^m(x)/dx are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20553
20554
20555
20556
20557
20558
20559
20560
20561
20562
20563
20564
20565
20566
20567
20568
20569
20570
20571
20572
20573
20574</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20553</span>

static VALUE
sf_s_legendre_deriv_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_array_e-class_method">
  
    .<strong>legendre_deriv_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x) values and their derivatives
dP_l^m(x)/dx are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20632
20633
20634
20635
20636
20637
20638
20639
20640
20641
20642
20643
20644
20645
20646
20647
20648
20649
20650
20651
20652
20653
20654
20655</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20632</span>

static VALUE
sf_s_legendre_deriv_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d-class_method">
  
    .<strong>legendre_H3d</strong>(l, lambda, eta)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the l-th radial eigenfunction of the
Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$
\eta &gt;= 0, $l \ge 0$
l &gt;= 0. In the flat limit this takes the form
$L^H3d_l(\lambda,\eta) = j_l(\lambda\eta)$
L^[H3d]_l(\lambda,\eta) = j_l(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22336
22337
22338
22339
22340
22341
22342
22343
22344
22345
22346
22347
22348
22349
22350
22351
22352
22353</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22336</span>

static VALUE
sf_s_legendre_H3d(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_0-class_method">
  
    .<strong>legendre_H3d_0</strong>(lambda, eta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the zeroth radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script>
L^[H3d]_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_0(\lambda,\eta) = j_0(\lambda\eta)$
L^[H3d]_0(\lambda,\eta) = j_0(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22122
22123
22124
22125
22126
22127
22128
22129
22130</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22122</span>

static VALUE
sf_s_legendre_H3d_0(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_0, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_0_e-class_method">
  
    .<strong>legendre_H3d_0_e</strong>(lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the zeroth radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script>
L^[H3d]_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_0(\lambda,\eta) = j_0(\lambda\eta)$
L^[H3d]_0(\lambda,\eta) = j_0(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22174
22175
22176
22177
22178
22179
22180
22181
22182
22183
22184
22185
22186
22187</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22174</span>

static VALUE
sf_s_legendre_H3d_0_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_1-class_method">
  
    .<strong>legendre_H3d_1</strong>(lambda, eta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first radial eigenfunction of the Laplacian on
the 3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script>
L^[H3d]_1(\lambda,\eta) := 1/\sqrt[\lambda^2 + 1] \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_1(\lambda,\eta) = j_1(\lambda\eta)$
L^[H3d]_1(\lambda,\eta) = j_1(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22229
22230
22231
22232
22233
22234
22235
22236
22237</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22229</span>

static VALUE
sf_s_legendre_H3d_1(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_1_e-class_method">
  
    .<strong>legendre_H3d_1_e</strong>(lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first radial eigenfunction of the Laplacian on
the 3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script>
L^[H3d]_1(\lambda,\eta) := 1/\sqrt[\lambda^2 + 1] \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_1(\lambda,\eta) = j_1(\lambda\eta)$
L^[H3d]_1(\lambda,\eta) = j_1(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22281
22282
22283
22284
22285
22286
22287
22288
22289
22290
22291
22292
22293
22294</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22281</span>

static VALUE
sf_s_legendre_H3d_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_array-class_method">
  
    .<strong>legendre_H3d_array</strong>(lmax, lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes an array of radial eigenfunctions
$L^H3d_l( \lambda, \eta)$
L^[H3d]_l(\lambda, \eta)
for $0 \le l \le lmax$
0 &lt;= l &lt;= lmax.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22459
22460
22461
22462
22463
22464
22465
22466
22467
22468
22469
22470
22471
22472
22473
22474
22475
22476
22477</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22459</span>

static VALUE
sf_s_legendre_H3d_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c0);    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_e-class_method">
  
    .<strong>legendre_H3d_e</strong>(l, lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the l-th radial eigenfunction of the
Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$
\eta &gt;= 0, $l \ge 0$
l &gt;= 0. In the flat limit this takes the form
$L^H3d_l(\lambda,\eta) = j_l(\lambda\eta)$
L^[H3d]_l(\lambda,\eta) = j_l(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22398
22399
22400
22401
22402
22403
22404
22405
22406
22407
22408
22409
22410
22411
22412
22413
22414
22415</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22398</span>

static VALUE
sf_s_legendre_H3d_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P1-class_method">
  
    .<strong>legendre_P1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19591
19592
19593
19594
19595
19596
19597
19598
19599</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19591</span>

static VALUE
sf_s_legendre_P1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P1_e-class_method">
  
    .<strong>legendre_P1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19719
19720
19721
19722
19723
19724
19725
19726
19727
19728
19729
19730
19731
19732</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19719</span>

static VALUE
sf_s_legendre_P1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P2-class_method">
  
    .<strong>legendre_P2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19633
19634
19635
19636
19637
19638
19639
19640
19641</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19633</span>

static VALUE
sf_s_legendre_P2(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P2_e-class_method">
  
    .<strong>legendre_P2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19768
19769
19770
19771
19772
19773
19774
19775
19776
19777
19778
19779
19780
19781</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19768</span>

static VALUE
sf_s_legendre_P2_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P3-class_method">
  
    .<strong>legendre_P3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19675
19676
19677
19678
19679
19680
19681
19682
19683</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19675</span>

static VALUE
sf_s_legendre_P3(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P3_e-class_method">
  
    .<strong>legendre_P3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19817
19818
19819
19820
19821
19822
19823
19824
19825
19826
19827
19828
19829
19830</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19817</span>

static VALUE
sf_s_legendre_P3_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl-class_method">
  
    .<strong>legendre_Pl</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomial $P_l(x)$
P_l(x) for a specific value of l,
x subject to $l \ge 0$
l &gt;= 0,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19869
19870
19871
19872
19873
19874
19875
19876
19877
19878
19879
19880</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19869</span>

static VALUE
sf_s_legendre_Pl(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl_array-class_method">
  
    .<strong>legendre_Pl_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute arrays of Legendre polynomials
P_l(x) and derivatives dP_l(x)/dx,
for l = 0, \dots, lmax,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19981
19982
19983
19984
19985
19986
19987
19988
19989
19990
19991
19992
19993
19994
19995
19996
19997
19998
19999</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19981</span>

static VALUE
sf_s_legendre_Pl_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c0);    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl_deriv_array-class_method">
  
    .<strong>legendre_Pl_deriv_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute arrays of Legendre polynomials
P_l(x) and derivatives dP_l(x)/dx,
for l = 0, \dots, lmax,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20044
20045
20046
20047
20048
20049
20050
20051
20052
20053
20054
20055
20056
20057
20058
20059
20060
20061
20062</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20044</span>

static VALUE
sf_s_legendre_Pl_deriv_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl_deriv_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c0);    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl_e-class_method">
  
    .<strong>legendre_Pl_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomial $P_l(x)$
P_l(x) for a specific value of l,
x subject to $l \ge 0$
l &gt;= 0,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19922
19923
19924
19925
19926
19927
19928
19929
19930
19931
19932
19933
19934
19935
19936
19937
19938
19939</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19922</span>

static VALUE
sf_s_legendre_Pl_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Plm-class_method">
  
    .<strong>legendre_Plm</strong>(l, m, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the associated Legendre polynomial
P_l^m(x) for $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21243
21244
21245
21246
21247
21248
21249
21250
21251
21252
21253
21254
21255
21256
21257
21258
21259
21260
21261
21262
21263</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21243</span>

static VALUE
sf_s_legendre_Plm(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Plm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Plm_e-class_method">
  
    .<strong>legendre_Plm_e</strong>(l, m, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the associated Legendre polynomial
P_l^m(x) for $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21309
21310
21311
21312
21313
21314
21315
21316
21317
21318
21319
21320
21321
21322
21323
21324
21325
21326
21327
21328
21329</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21309</span>

static VALUE
sf_s_legendre_Plm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Plm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q0-class_method">
  
    .<strong>legendre_Q0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_0(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20095
20096
20097
20098
20099
20100
20101
20102
20103</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20095</span>

static VALUE
sf_s_legendre_Q0(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q0_e-class_method">
  
    .<strong>legendre_Q0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_0(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20138
20139
20140
20141
20142
20143
20144
20145
20146
20147
20148
20149
20150
20151</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20138</span>

static VALUE
sf_s_legendre_Q0_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q1-class_method">
  
    .<strong>legendre_Q1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_1(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20184
20185
20186
20187
20188
20189
20190
20191
20192</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20184</span>

static VALUE
sf_s_legendre_Q1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q1_e-class_method">
  
    .<strong>legendre_Q1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_1(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20227
20228
20229
20230
20231
20232
20233
20234
20235
20236
20237
20238
20239
20240</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20227</span>

static VALUE
sf_s_legendre_Q1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Ql-class_method">
  
    .<strong>legendre_Ql</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_l(x) for x &gt;
-1, $x \ne 1$
x != 1 and $l \ge 0$
l &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20277
20278
20279
20280
20281
20282
20283
20284
20285
20286
20287
20288</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20277</span>

static VALUE
sf_s_legendre_Ql(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Ql, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Ql_e-class_method">
  
    .<strong>legendre_Ql_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_l(x) for x &gt;
-1, $x \ne 1$
x != 1 and $l \ge 0$
l &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20328
20329
20330
20331
20332
20333
20334
20335
20336
20337
20338
20339
20340
20341
20342
20343
20344
20345</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20328</span>

static VALUE
sf_s_legendre_Ql_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Ql_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_sphPlm-class_method">
  
    .<strong>legendre_sphPlm</strong>(l, m, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized associated Legendre polynomial
$\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$
\sqrt[(2l+1)/(4\pi)] \sqrt[(l-m)!/(l+m)!] P_l^m(x) suitable
for use in spherical harmonics.  The parameters must satisfy $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1. Theses routines avoid the overflows
that occur for the standard normalization of P_l^m(x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21375
21376
21377
21378
21379
21380
21381
21382
21383
21384
21385
21386
21387
21388
21389
21390
21391
21392
21393
21394
21395</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21375</span>

static VALUE
sf_s_legendre_sphPlm(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_sphPlm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_sphPlm_e-class_method">
  
    .<strong>legendre_sphPlm_e</strong>(l, m, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized associated Legendre polynomial
$\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$
\sqrt[(2l+1)/(4\pi)] \sqrt[(l-m)!/(l+m)!] P_l^m(x) suitable
for use in spherical harmonics.  The parameters must satisfy $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1. Theses routines avoid the overflows
that occur for the standard normalization of P_l^m(x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21444
21445
21446
21447
21448
21449
21450
21451
21452
21453
21454
21455
21456
21457
21458
21459
21460
21461
21462
21463
21464</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21444</span>

static VALUE
sf_s_legendre_sphPlm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_sphPlm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnbeta-class_method">
  
    .<strong>lnbeta</strong>(a, b)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Beta Function, \log(B(a,b))
subject to a and b not
being negative integers.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3339
3340
3341
3342
3343
3344
3345
3346
3347</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3339</span>

static VALUE
sf_s_lnbeta(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnbeta, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnbeta_e-class_method">
  
    .<strong>lnbeta_e</strong>(a, b)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Beta Function, \log(B(a,b))
subject to a and b not
being negative integers.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3385
3386
3387
3388
3389
3390
3391
3392
3393
3394
3395
3396
3397
3398</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3385</span>

static VALUE
sf_s_lnbeta_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnbeta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnchoose-class_method">
  
    .<strong>lnchoose</strong>(n, m)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of n choose m.  This is
equivalent to the sum \log(n!) - \log(m!) - \log((n-m)!).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2396
2397
2398
2399
2400
2401
2402
2403
2404
2405
2406
2407
2408
2409</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2396</span>

static VALUE
sf_s_lnchoose(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnchoose,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnchoose_e-class_method">
  
    .<strong>lnchoose_e</strong>(n, m)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of n choose m.  This is
equivalent to the sum \log(n!) - \log(m!) - \log((n-m)!).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2446
2447
2448
2449
2450
2451
2452
2453
2454
2455
2456
2457
2458
2459</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2446</span>

static VALUE
sf_s_lnchoose_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnchoose_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lncosh-class_method">
  
    .<strong>lncosh</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\cosh(x)) for any x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1062
1063
1064
1065
1066
1067
1068
1069
1070</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1062</span>

static VALUE
sf_s_lncosh(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lncosh, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lncosh_e-class_method">
  
    .<strong>lncosh_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\cosh(x)) for any x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1103
1104
1105
1106
1107
1108
1109
1110
1111
1112
1113
1114
1115
1116</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1103</span>

static VALUE
sf_s_lncosh_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lncosh_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lndoublefact-class_method">
  
    .<strong>lndoublefact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the double factorial of n,
\log(n!!).
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2210
2211
2212
2213
2214
2215
2216
2217
2218</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2210</span>

static VALUE
sf_s_lndoublefact(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lndoublefact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lndoublefact_e-class_method">
  
    .<strong>lndoublefact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the double factorial of n,
\log(n!!).
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2252
2253
2254
2255
2256
2257
2258
2259
2260
2261
2262
2263
2264
2265</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2252</span>

static VALUE
sf_s_lndoublefact_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lndoublefact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnfact-class_method">
  
    .<strong>lnfact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the factorial of n,
\log(n!).  The algorithm is faster than computing
\ln(\Gamma(n+1)) via gsl_sf_lngamma for n &lt; 170,
but defers for larger n.
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2120
2121
2122
2123
2124
2125
2126
2127
2128</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2120</span>

static VALUE
sf_s_lnfact(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnfact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnfact_e-class_method">
  
    .<strong>lnfact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the factorial of n,
\log(n!).  The algorithm is faster than computing
\ln(\Gamma(n+1)) via gsl_sf_lngamma for n &lt; 170,
but defers for larger n.
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2164
2165
2166
2167
2168
2169
2170
2171
2172
2173
2174
2175
2176
2177</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2164</span>

static VALUE
sf_s_lnfact_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnfact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma-class_method">
  
    .<strong>lngamma</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Gamma function,
\log(\Gamma(x)), subject to x not being a negative
integer or zero.  For x&lt;0 the real part of \log(\Gamma(x)) is
returned, which is equivalent to \log(|\Gamma(x)|).  The function
is computed using the real Lanczos method.
exceptions: GSL_EDOM, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1546
1547
1548
1549
1550
1551
1552
1553
1554</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1546</span>

static VALUE
sf_s_lngamma(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma_complex_e-class_method">
  
    .<strong>lngamma_complex_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes \log(\Gamma(z)) for complex z=z_r+i
z_i and z not a negative integer or zero, using the complex Lanczos
method.  The returned parameters are lnr = \log|\Gamma(z)| and
arg = \arg(\Gamma(z)) in (-\pi,\pi].  Note that the phase
part (arg) is not well-determined when |z| is very large,
due to inevitable roundoff in restricting to (-\pi,\pi].  This
will result in a GSL_ELOSS error when it occurs.  The absolute
value part (lnr), however, never suffers from loss of precision.
exceptions: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [lnr.val, lnr.err, arg.val, arg.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1886
1887
1888
1889
1890
1891
1892
1893
1894
1895
1896
1897
1898
1899</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1886</span>

static VALUE
sf_s_lngamma_complex_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma_complex_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma_e-class_method">
  
    .<strong>lngamma_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Gamma function,
\log(\Gamma(x)), subject to x not being a negative
integer or zero.  For x&lt;0 the real part of \log(\Gamma(x)) is
returned, which is equivalent to \log(|\Gamma(x)|).  The function
is computed using the real Lanczos method.
exceptions: GSL_EDOM, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1591
1592
1593
1594
1595
1596
1597
1598
1599
1600
1601
1602
1603
1604</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1591</span>

static VALUE
sf_s_lngamma_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma_sgn_e-class_method">
  
    .<strong>lngamma_sgn_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the sign of the gamma function and the logarithm of
its magnitude, subject to x not being a negative integer or zero.  The
function is computed using the real Lanczos method.  The value of the
gamma function and its error can be reconstructed using the relation
\Gamma(x) = sgn * \exp(result_lg), taking into account the two
components of result_lg.
exceptions: GSL_EDOM, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_lg.val, result_lg.err, sgn, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1645
1646
1647
1648
1649
1650
1651
1652
1653
1654
1655
1656
1657
1658</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1645</span>

static VALUE
sf_s_lngamma_sgn_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma_sgn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnpoch-class_method">
  
    .<strong>lnpoch</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Pochhammer symbol,
\log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2698
2699
2700
2701
2702
2703
2704
2705
2706</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2698</span>

static VALUE
sf_s_lnpoch(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnpoch, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnpoch_e-class_method">
  
    .<strong>lnpoch_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Pochhammer symbol,
\log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2743
2744
2745
2746
2747
2748
2749
2750
2751
2752
2753
2754
2755
2756</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2743</span>

static VALUE
sf_s_lnpoch_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnpoch_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnpoch_sgn_e-class_method">
  
    .<strong>lnpoch_sgn_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sign of the Pochhammer symbol and the
logarithm of its magnitude.  The computed parameters are result =
\log(|(a)_x|) with a corresponding error term,
and sgn = \sgn((a)_x) where (a)_x =
\Gamma(a + x)/\Gamma(a).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, sgn, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2799
2800
2801
2802
2803
2804
2805
2806
2807
2808
2809
2810
2811
2812</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2799</span>

static VALUE
sf_s_lnpoch_sgn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnpoch_sgn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnsinh-class_method">
  
    .<strong>lnsinh</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\sinh(x)) for x &gt; 0.
Domain: x &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


976
977
978
979
980
981
982
983
984</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 976</span>

static VALUE
sf_s_lnsinh(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnsinh, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnsinh_e-class_method">
  
    .<strong>lnsinh_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\sinh(x)) for x &gt; 0.
Domain: x &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1018
1019
1020
1021
1022
1023
1024
1025
1026
1027
1028
1029
1030
1031</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1018</span>

static VALUE
sf_s_lnsinh_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnsinh_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log-class_method">
  
    .<strong>log</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of x, \log(x), for
x &gt; 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


59
60
61
62
63
64
65
66
67</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 59</span>

static VALUE
sf_s_log(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx-class_method">
  
    .<strong>log_1plusx</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


289
290
291
292
293
294
295
296
297</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 289</span>

static VALUE
sf_s_log_1plusx(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx_e-class_method">
  
    .<strong>log_1plusx_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


332
333
334
335
336
337
338
339
340
341
342
343
344
345</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 332</span>

static VALUE
sf_s_log_1plusx_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx_mx-class_method">
  
    .<strong>log_1plusx_mx</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) - x for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


378
379
380
381
382
383
384
385
386</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 378</span>

static VALUE
sf_s_log_1plusx_mx(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx_mx, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx_mx_e-class_method">
  
    .<strong>log_1plusx_mx_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) - x for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


421
422
423
424
425
426
427
428
429
430
431
432
433
434</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 421</span>

static VALUE
sf_s_log_1plusx_mx_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx_mx_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_abs-class_method">
  
    .<strong>log_abs</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the magnitude of x,
\log(|x|), for x \ne 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


146
147
148
149
150
151
152
153
154</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 146</span>

static VALUE
sf_s_log_abs(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_abs, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_abs_e-class_method">
  
    .<strong>log_abs_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the magnitude of x,
\log(|x|), for x \ne 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


188
189
190
191
192
193
194
195
196
197
198
199
200
201</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 188</span>

static VALUE
sf_s_log_abs_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_abs_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_e-class_method">
  
    .<strong>log_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of x, \log(x), for
x &gt; 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


101
102
103
104
105
106
107
108
109
110
111
112
113
114</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 101</span>

static VALUE
sf_s_log_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_erfc-class_method">
  
    .<strong>log_erfc</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the complementary error function
\log(\erfc(x)).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8751
8752
8753
8754
8755
8756
8757
8758
8759</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8751</span>

static VALUE
sf_s_log_erfc(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_erfc, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_erfc_e-class_method">
  
    .<strong>log_erfc_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the complementary error function
\log(\erfc(x)).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8793
8794
8795
8796
8797
8798
8799
8800
8801
8802
8803
8804
8805
8806</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8793</span>

static VALUE
sf_s_log_erfc_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_erfc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_a-class_method">
  
    .<strong>mathieu_a</strong>(n, q)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10462
10463
10464
10465
10466
10467
10468
10469
10470
10471
10472
10473</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10462</span>

static VALUE
sf_s_mathieu_a(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_a, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_a_e-class_method">
  
    .<strong>mathieu_a_e</strong>(n, q)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10511
10512
10513
10514
10515
10516
10517
10518
10519
10520
10521
10522
10523
10524
10525
10526
10527
10528</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10511</span>

static VALUE
sf_s_mathieu_a_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_a_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_b-class_method">
  
    .<strong>mathieu_b</strong>(n, q)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10564
10565
10566
10567
10568
10569
10570
10571
10572
10573
10574
10575</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10564</span>

static VALUE
sf_s_mathieu_b(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_b, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_b_e-class_method">
  
    .<strong>mathieu_b_e</strong>(n, q)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10613
10614
10615
10616
10617
10618
10619
10620
10621
10622
10623
10624
10625
10626
10627
10628
10629
10630</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10613</span>

static VALUE
sf_s_mathieu_b_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_b_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_ce-class_method">
  
    .<strong>mathieu_ce</strong>(n, q, x)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10668
10669
10670
10671
10672
10673
10674
10675
10676
10677
10678
10679</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10668</span>

static VALUE
sf_s_mathieu_ce(VALUE mod, VALUE v0, VALUE v1, VALUE v2)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_ce, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};
    int opts[1];

    opts[0] = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, opts, 2, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_ce_e-class_method">
  
    .<strong>mathieu_ce_e</strong>(n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10719
10720
10721
10722
10723
10724
10725
10726
10727
10728
10729
10730
10731
10732
10733
10734
10735
10736</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10719</span>

static VALUE
sf_s_mathieu_ce_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_ce_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Mc-class_method">
  
    .<strong>mathieu_Mc</strong>(j, n, q, x)  &#x21d2; <tt>Numo::Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^<a href="q,x">(j)</a> and
$Ms_n^(j)(q,x)$
Ms_n^<a href="q,x">(j)</a> of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^[(3)] = M_n^[(1)] + iM_n^[(2)] and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^[(4)] = M_n^[(1)] - iM_n^[(2)],
where
$M_n^(j) = Mc_n^(j)$
M_n^[(j)] = Mc_n^[(j)] or
$Ms_n^(j)$
Ms_n^[(j)].</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10899
10900
10901
10902
10903
10904
10905
10906
10907
10908
10909
10910
10911
10912
10913
10914
10915
10916
10917
10918
10919</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10899</span>

static VALUE
sf_s_mathieu_Mc(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Mc,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Mc_e-class_method">
  
    .<strong>mathieu_Mc_e</strong>(j, n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^<a href="q,x">(j)</a> and
$Ms_n^(j)(q,x)$
Ms_n^<a href="q,x">(j)</a> of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^[(3)] = M_n^[(1)] + iM_n^[(2)] and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^[(4)] = M_n^[(1)] - iM_n^[(2)],
where
$M_n^(j) = Mc_n^(j)$
M_n^[(j)] = Mc_n^[(j)] or
$Ms_n^(j)$
Ms_n^[(j)].</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10979
10980
10981
10982
10983
10984
10985
10986
10987
10988
10989
10990
10991
10992
10993
10994
10995
10996
10997
10998
10999</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10979</span>

static VALUE
sf_s_mathieu_Mc_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Mc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Ms-class_method">
  
    .<strong>mathieu_Ms</strong>(j, n, q, x)  &#x21d2; <tt>Numo::Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^<a href="q,x">(j)</a> and
$Ms_n^(j)(q,x)$
Ms_n^<a href="q,x">(j)</a> of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^[(3)] = M_n^[(1)] + iM_n^[(2)] and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^[(4)] = M_n^[(1)] - iM_n^[(2)],
where
$M_n^(j) = Mc_n^(j)$
M_n^[(j)] = Mc_n^[(j)] or
$Ms_n^(j)$
Ms_n^[(j)].</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11056
11057
11058
11059
11060
11061
11062
11063
11064
11065
11066
11067
11068
11069
11070
11071
11072
11073
11074
11075
11076</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11056</span>

static VALUE
sf_s_mathieu_Ms(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Ms,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Ms_e-class_method">
  
    .<strong>mathieu_Ms_e</strong>(j, n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^<a href="q,x">(j)</a> and
$Ms_n^(j)(q,x)$
Ms_n^<a href="q,x">(j)</a> of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^[(3)] = M_n^[(1)] + iM_n^[(2)] and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^[(4)] = M_n^[(1)] - iM_n^[(2)],
where
$M_n^(j) = Mc_n^(j)$
M_n^[(j)] = Mc_n^[(j)] or
$Ms_n^(j)$
Ms_n^[(j)].</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11136
11137
11138
11139
11140
11141
11142
11143
11144
11145
11146
11147
11148
11149
11150
11151
11152
11153
11154
11155
11156</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11136</span>

static VALUE
sf_s_mathieu_Ms_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Ms_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_se-class_method">
  
    .<strong>mathieu_se</strong>(n, q, x)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10774
10775
10776
10777
10778
10779
10780
10781
10782
10783
10784
10785</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10774</span>

static VALUE
sf_s_mathieu_se(VALUE mod, VALUE v0, VALUE v1, VALUE v2)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_se, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};
    int opts[1];

    opts[0] = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, opts, 2, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_se_e-class_method">
  
    .<strong>mathieu_se_e</strong>(n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10825
10826
10827
10828
10829
10830
10831
10832
10833
10834
10835
10836
10837
10838
10839
10840
10841
10842</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10825</span>

static VALUE
sf_s_mathieu_se_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_se_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="multiply_e-class_method">
  
    .<strong>multiply_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function multiplies x and y storing the product and its
associated error in result.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9106
9107
9108
9109
9110
9111
9112
9113
9114
9115
9116
9117
9118
9119</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9106</span>

static VALUE
sf_s_multiply_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_multiply_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="multiply_err_e-class_method">
  
    .<strong>multiply_err_e</strong>(x, dx, y, dy)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function multiplies x and y with associated absolute
errors dx and dy.  The product
$xy \pm xy \sqrt+(dy/y)^2$
xy +/- xy \sqrt((dx/x)^2 +(dy/y)^2)
is stored in result.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dy</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9165
9166
9167
9168
9169
9170
9171
9172
9173
9174
9175
9176
9177
9178</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9165</span>

static VALUE
sf_s_multiply_err_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_multiply_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="poch-class_method">
  
    .<strong>poch</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a +
x)/\Gamma(a).  The Pochhammer symbol is also known as the Apell symbol and
sometimes written as (a,x).  When a and a+x
are negative integers or zero, the limiting value of the ratio is returned.
exceptions:  GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2603
2604
2605
2606
2607
2608
2609
2610
2611</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2603</span>

static VALUE
sf_s_poch(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_poch, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="poch_e-class_method">
  
    .<strong>poch_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a +
x)/\Gamma(a).  The Pochhammer symbol is also known as the Apell symbol and
sometimes written as (a,x).  When a and a+x
are negative integers or zero, the limiting value of the ratio is returned.
exceptions:  GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2650
2651
2652
2653
2654
2655
2656
2657
2658
2659
2660
2661
2662
2663</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2650</span>

static VALUE
sf_s_poch_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_poch_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pochrel-class_method">
  
    .<strong>pochrel</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the relative Pochhammer symbol ((a)_x -
1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2847
2848
2849
2850
2851
2852
2853
2854
2855</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2847</span>

static VALUE
sf_s_pochrel(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_pochrel, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pochrel_e-class_method">
  
    .<strong>pochrel_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the relative Pochhammer symbol ((a)_x -
1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2892
2893
2894
2895
2896
2897
2898
2899
2900
2901
2902
2903
2904
2905</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2892</span>

static VALUE
sf_s_pochrel_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_pochrel_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="polar_to_rect-class_method">
  
    .<strong>polar_to_rect</strong>(r, theta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function converts the polar coordinates (r,theta) to
rectilinear coordinates (x,y), x = r\cos(\theta),
y = r\sin(\theta).
Exceptional Return Values: GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [x.val, x.err, y.val, y.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1157
1158
1159
1160
1161
1162
1163
1164
1165
1166
1167
1168
1169
1170</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1157</span>

static VALUE
sf_s_polar_to_rect(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_polar_to_rect,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pow_int-class_method">
  
    .<strong>pow_int</strong>(x, n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the power x^n for integer n.  The
power is computed using the minimum number of multiplications. For
example, x^8 is computed as ((x^2)^2)^2, requiring only 3
multiplications.  For reasons of efficiency, these functions do not
check for overflow or underflow conditions.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10175
10176
10177
10178
10179
10180
10181
10182
10183</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10175</span>

static VALUE
sf_s_pow_int(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_pow_int, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pow_int_e-class_method">
  
    .<strong>pow_int_e</strong>(x, n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the power x^n for integer n.  The
power is computed using the minimum number of multiplications. For
example, x^8 is computed as ((x^2)^2)^2, requiring only 3
multiplications.  For reasons of efficiency, these functions do not
check for overflow or underflow conditions.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10223
10224
10225
10226
10227
10228
10229
10230
10231
10232
10233
10234
10235
10236
10237
10238
10239
10240</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10223</span>

static VALUE
sf_s_pow_int_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c1;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_pow_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi-class_method">
  
    .<strong>psi</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(x) for general
x, x \ne 0.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7599
7600
7601
7602
7603
7604
7605
7606
7607</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7599</span>

static VALUE
sf_s_psi(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1-class_method">
  
    .<strong>psi_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(x) for
general x.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7854
7855
7856
7857
7858
7859
7860
7861
7862</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7854</span>

static VALUE
sf_s_psi_1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1_e-class_method">
  
    .<strong>psi_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(x) for
general x.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7897
7898
7899
7900
7901
7902
7903
7904
7905
7906
7907
7908
7909
7910</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7897</span>

static VALUE
sf_s_psi_1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1_int-class_method">
  
    .<strong>psi_1_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(n) for
positive integer n.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7778
7779
7780
7781
7782
7783
7784
7785
7786</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7778</span>

static VALUE
sf_s_psi_1_int(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1_int_e-class_method">
  
    .<strong>psi_1_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(n) for
positive integer n.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7801
7802
7803
7804
7805
7806
7807
7808
7809
7810
7811
7812
7813
7814
7815
7816
7817
7818
7819
7820
7821</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7801</span>

static VALUE
sf_s_psi_1_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
    c2 = gsl_sf_psi_1_int_e(c0,&amp;c1);
    
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1piy-class_method">
  
    .<strong>psi_1piy</strong>(y)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the real part of the digamma function on the line
1+i y, \Re[\psi(1 + i y)].
exceptions: none
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7688
7689
7690
7691
7692
7693
7694
7695
7696</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7688</span>

static VALUE
sf_s_psi_1piy(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1piy, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1piy_e-class_method">
  
    .<strong>psi_1piy_e</strong>(y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the real part of the digamma function on the line
1+i y, \Re[\psi(1 + i y)].
exceptions: none
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7731
7732
7733
7734
7735
7736
7737
7738
7739
7740
7741
7742
7743
7744</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7731</span>

static VALUE
sf_s_psi_1piy_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1piy_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_e-class_method">
  
    .<strong>psi_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(x) for general
x, x \ne 0.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7642
7643
7644
7645
7646
7647
7648
7649
7650
7651
7652
7653
7654
7655</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7642</span>

static VALUE
sf_s_psi_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_int-class_method">
  
    .<strong>psi_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(n) for positive
integer n.  The digamma function is also called the Psi function.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7523
7524
7525
7526
7527
7528
7529
7530
7531</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7523</span>

static VALUE
sf_s_psi_int(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_int_e-class_method">
  
    .<strong>psi_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(n) for positive
integer n.  The digamma function is also called the Psi function.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7546
7547
7548
7549
7550
7551
7552
7553
7554
7555
7556
7557
7558
7559
7560
7561
7562
7563
7564
7565
7566</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7546</span>

static VALUE
sf_s_psi_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
    c2 = gsl_sf_psi_int_e(c0,&amp;c1);
    
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_n-class_method">
  
    .<strong>psi_n</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the polygamma function $\psi^(n)(x)$
\psi^<a href="x">(n)</a> for
$n \ge 0$
n &gt;= 0, x &gt; 0.
Domain: n &gt;= 0, x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7948
7949
7950
7951
7952
7953
7954
7955
7956
7957
7958
7959</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7948</span>

static VALUE
sf_s_psi_n(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_n, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_n_e-class_method">
  
    .<strong>psi_n_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the polygamma function $\psi^(n)(x)$
\psi^<a href="x">(n)</a> for
$n \ge 0$
n &gt;= 0, x &gt; 0.
Domain: n &gt;= 0, x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8000
8001
8002
8003
8004
8005
8006
8007
8008
8009
8010
8011
8012
8013
8014
8015
8016
8017</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8000</span>

static VALUE
sf_s_psi_n_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="rect_to_polar-class_method">
  
    .<strong>rect_to_polar</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function converts the rectilinear coordinates (x,y) to
polar coordinates (r,theta), such that x =
r\cos(\theta), y = r\sin(\theta).  The argument theta
lies in the range [-\pi, \pi].
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [r.val, r.err, theta.val, theta.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1212
1213
1214
1215
1216
1217
1218
1219
1220
1221
1222
1223
1224
1225</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1212</span>

static VALUE
sf_s_rect_to_polar(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_rect_to_polar,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Shi-class_method">
  
    .<strong>Shi</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$
Shi(x) = \int_0^x dt \sinh(t)/t.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5726
5727
5728
5729
5730
5731
5732
5733
5734</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5726</span>

static VALUE
sf_s_Shi(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Shi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Shi_e-class_method">
  
    .<strong>Shi_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$
Shi(x) = \int_0^x dt \sinh(t)/t.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5768
5769
5770
5771
5772
5773
5774
5775
5776
5777
5778
5779
5780
5781</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5768</span>

static VALUE
sf_s_Shi_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Shi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Si-class_method">
  
    .<strong>Si</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Si</a></span>(x) = \int_0^x dt \sin(t)/t$
Si(x) = \int_0^x dt \sin(t)/t.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5993
5994
5995
5996
5997
5998
5999
6000
6001</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5993</span>

static VALUE
sf_s_Si(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Si, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Si_e-class_method">
  
    .<strong>Si_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Si</a></span>(x) = \int_0^x dt \sin(t)/t$
Si(x) = \int_0^x dt \sin(t)/t.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6035
6036
6037
6038
6039
6040
6041
6042
6043
6044
6045
6046
6047
6048</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6035</span>

static VALUE
sf_s_Si_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Si_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sin-class_method">
  
    .<strong>sin</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sine function \sin(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


465
466
467
468
469
470
471
472
473</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 465</span>

static VALUE
sf_s_sin(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_sin, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sin_e-class_method">
  
    .<strong>sin_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sine function \sin(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


506
507
508
509
510
511
512
513
514
515
516
517
518
519</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 506</span>

static VALUE
sf_s_sin_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_sin_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sin_err_e-class_method">
  
    .<strong>sin_err_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the sine of an angle x with an associated
absolute error dx,
$\sin(x \pm dx)$
\sin(x \pm dx).  Note that this function is provided in the error-handling form only since
its purpose is to compute the propagated error.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1353
1354
1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
1365
1366</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1353</span>

static VALUE
sf_s_sin_err_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_sin_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,2,v0,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sinc-class_method">
  
    .<strong>sinc</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any
value of x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


729
730
731
732
733
734
735
736
737</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 729</span>

static VALUE
sf_s_sinc(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_sinc, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sinc_e-class_method">
  
    .<strong>sinc_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any
value of x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


771
772
773
774
775
776
777
778
779
780
781
782
783
784</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 771</span>

static VALUE
sf_s_sinc_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_sinc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_1-class_method">
  
    .<strong>synchrotron_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first synchrotron function
$x \int_x^\infty dt K_5/3(t)$
x \int_x^\infty dt K_<a href="t">5/3</a> for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10275
10276
10277
10278
10279
10280
10281
10282
10283</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10275</span>

static VALUE
sf_s_synchrotron_1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_1_e-class_method">
  
    .<strong>synchrotron_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first synchrotron function
$x \int_x^\infty dt K_5/3(t)$
x \int_x^\infty dt K_<a href="t">5/3</a> for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10320
10321
10322
10323
10324
10325
10326
10327
10328
10329
10330
10331
10332
10333</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10320</span>

static VALUE
sf_s_synchrotron_1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_2-class_method">
  
    .<strong>synchrotron_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second synchrotron function
$x K_2/3(x)$
x K_<a href="x">2/3</a> for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10368
10369
10370
10371
10372
10373
10374
10375
10376</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10368</span>

static VALUE
sf_s_synchrotron_2(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_2_e-class_method">
  
    .<strong>synchrotron_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second synchrotron function
$x K_2/3(x)$
x K_<a href="x">2/3</a> for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10413
10414
10415
10416
10417
10418
10419
10420
10421
10422
10423
10424
10425
10426</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10413</span>

static VALUE
sf_s_synchrotron_2_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="taylorcoeff-class_method">
  
    .<strong>taylorcoeff</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Taylor coefficient x^n / n! for
$x \ge 0$
x &gt;= 0,
$n \ge 0$
n &gt;= 0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2497
2498
2499
2500
2501
2502
2503
2504
2505
2506
2507
2508</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2497</span>

static VALUE
sf_s_taylorcoeff(VALUE mod, VALUE v0, VALUE v1)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_taylorcoeff, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="taylorcoeff_e-class_method">
  
    .<strong>taylorcoeff_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Taylor coefficient x^n / n! for
$x \ge 0$
x &gt;= 0,
$n \ge 0$
n &gt;= 0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2549
2550
2551
2552
2553
2554
2555
2556
2557
2558
2559
2560
2561
2562
2563
2564
2565
2566</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2549</span>

static VALUE
sf_s_taylorcoeff_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_taylorcoeff_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_2-class_method">
  
    .<strong>transport_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(2,x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3538
3539
3540
3541
3542
3543
3544
3545
3546</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3538</span>

static VALUE
sf_s_transport_2(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_2_e-class_method">
  
    .<strong>transport_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(2,x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3579
3580
3581
3582
3583
3584
3585
3586
3587
3588
3589
3590
3591
3592</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3579</span>

static VALUE
sf_s_transport_2_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_3-class_method">
  
    .<strong>transport_3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(3,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3623
3624
3625
3626
3627
3628
3629
3630
3631</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3623</span>

static VALUE
sf_s_transport_3(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_3_e-class_method">
  
    .<strong>transport_3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(3,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3664
3665
3666
3667
3668
3669
3670
3671
3672
3673
3674
3675
3676
3677</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3664</span>

static VALUE
sf_s_transport_3_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_4-class_method">
  
    .<strong>transport_4</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(4,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3708
3709
3710
3711
3712
3713
3714
3715
3716</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3708</span>

static VALUE
sf_s_transport_4(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_4, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_4_e-class_method">
  
    .<strong>transport_4_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(4,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3749
3750
3751
3752
3753
3754
3755
3756
3757
3758
3759
3760
3761
3762</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3749</span>

static VALUE
sf_s_transport_4_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_4_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_5-class_method">
  
    .<strong>transport_5</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(5,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3793
3794
3795
3796
3797
3798
3799
3800
3801</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3793</span>

static VALUE
sf_s_transport_5(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_5, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_5_e-class_method">
  
    .<strong>transport_5_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(5,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3834
3835
3836
3837
3838
3839
3840
3841
3842
3843
3844
3845
3846
3847</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3834</span>

static VALUE
sf_s_transport_5_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_5_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta-class_method">
  
    .<strong>zeta</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(s)
for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19081
19082
19083
19084
19085
19086
19087
19088
19089</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19081</span>

static VALUE
sf_s_zeta(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zeta, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta_e-class_method">
  
    .<strong>zeta_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(s)
for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19125
19126
19127
19128
19129
19130
19131
19132
19133
19134
19135
19136
19137
19138</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19125</span>

static VALUE
sf_s_zeta_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_zeta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta_int-class_method">
  
    .<strong>zeta_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(n)
for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19003
19004
19005
19006
19007
19008
19009
19010
19011</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19003</span>

static VALUE
sf_s_zeta_int(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zeta_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta_int_e-class_method">
  
    .<strong>zeta_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(n)
for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19027
19028
19029
19030
19031
19032
19033
19034
19035
19036
19037
19038
19039
19040
19041
19042
19043
19044
19045
19046
19047</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19027</span>

static VALUE
sf_s_zeta_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
    c2 = gsl_sf_zeta_int_e(c0,&amp;c1);
    
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1-class_method">
  
    .<strong>zetam1</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(s) - 1 for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19248
19249
19250
19251
19252
19253
19254
19255
19256</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19248</span>

static VALUE
sf_s_zetam1(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zetam1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1_e-class_method">
  
    .<strong>zetam1_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(s) - 1 for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19291
19292
19293
19294
19295
19296
19297
19298
19299
19300
19301
19302
19303
19304</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19291</span>

static VALUE
sf_s_zetam1_e(VALUE mod,VALUE v0)
{
    
    

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_zetam1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
    return na_ndloop(&amp;ndf,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1_int-class_method">
  
    .<strong>zetam1_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(n) - 1 for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19172
19173
19174
19175
19176
19177
19178
19179
19180</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19172</span>

static VALUE
sf_s_zetam1_int(VALUE mod, VALUE v0)
{
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zetam1_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1_int_e-class_method">
  
    .<strong>zetam1_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(n) - 1 for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19195
19196
19197
19198
19199
19200
19201
19202
19203
19204
19205
19206
19207
19208
19209
19210
19211
19212
19213
19214
19215</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19195</span>

static VALUE
sf_s_zetam1_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
    c2 = gsl_sf_zetam1_int_e(c0,&amp;c1);
    
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Thu Jan 18 17:28:55 2018 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.12 (ruby-2.5.0).
</div>

    </div>
  </body>
</html>